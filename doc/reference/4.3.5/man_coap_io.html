<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoap: coap_io(3)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcoap<span id="projectnumber">&#160;4.3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('man_coap_io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">coap_io(3)</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>coap_io</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="idm1"></a><div class="titlepage"></div><div class="refnamediv"><h2>NAME</h2><p><a href="man_coap_io.html#coap_io" target="_self">coap_io</a>, <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>, <a href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a>, <a href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a>, <a href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a>, <a href="man_coap_io_do_io.html#coap_io_do_io" target="_self">coap_io_do_io</a>, <a href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a>, <a href="man_coap_io_do_epoll.html#coap_io_do_epoll" target="_self">coap_io_do_epoll</a>, <a href="man_coap_io_pending.html#coap_io_pending" target="_self">coap_io_pending</a>, <a href="man_coap_can_exit.html#coap_can_exit" target="_self">coap_can_exit</a> - Work with CoAP I/O to do the packet send and receives </p></div><div class="refsynopsisdiv"><a id="_synopsis"></a><h2>SYNOPSIS</h2><p><span class="strong"><strong>#include &lt;coap3/coap.h&gt;</strong></span></p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>(coap_context_t *<span class="emphasis"><em>context</em></span>, uint32_t <span class="emphasis"><em>timeout_ms</em></span>)</strong></span>;</p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a>(coap_context_t *<span class="emphasis"><em>context</em></span>,
uint32_t <span class="emphasis"><em>timeout_ms</em></span>, int <span class="emphasis"><em>nfds</em></span>, fd_set *<span class="emphasis"><em>readfds</em></span>, fd_set *<span class="emphasis"><em>writefds</em></span>,
fd_set *<span class="emphasis"><em>exceptfds</em></span>)</strong></span>;</p><p><span class="strong"><strong>int coap_context_get_<a class="st-synopsis" href="man_coap_fd.html#coap_fd" target="_self">coap_fd</a>(const coap_context_t *<span class="emphasis"><em>context</em></span>)</strong></span>;</p><p><span class="strong"><strong>unsigned int <a class="st-synopsis" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a>(coap_context_t *<span class="emphasis"><em>context</em></span>,
coap_socket_t *<span class="emphasis"><em>sockets</em></span>[], unsigned int <span class="emphasis"><em>max_sockets</em></span>,
unsigned int *<span class="emphasis"><em>num_sockets</em></span>, coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>void <a class="st-synopsis" href="man_coap_io_do_io.html#coap_io_do_io" target="_self">coap_io_do_io</a>(coap_context_t *<span class="emphasis"><em>context</em></span>, coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>unsigned int <a class="st-synopsis" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a>(coap_context_t *<span class="emphasis"><em>context</em></span>,
coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>void <a class="st-synopsis" href="man_coap_io_do_epoll.html#coap_io_do_epoll" target="_self">coap_io_do_epoll</a>(coap_context_t *<span class="emphasis"><em>context</em></span>, struct epoll_event *<span class="emphasis"><em>events</em></span>,
size_t <span class="emphasis"><em>nevents</em></span>)</strong></span>;</p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_io_pending.html#coap_io_pending" target="_self">coap_io_pending</a>(coap_context_t *<span class="emphasis"><em>context</em></span>)</strong></span>;</p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_can_exit.html#coap_can_exit" target="_self">coap_can_exit</a>(coap_context_t *<span class="emphasis"><em>context</em></span>)</strong></span>;</p><p>For specific (D)TLS library support, link with
<span class="strong"><strong>-lcoap-3-notls</strong></span>, <span class="strong"><strong>-lcoap-3-gnutls</strong></span>,
<span class="strong"><strong>-lcoap-3-openssl</strong></span>, <span class="strong"><strong>-lcoap-3-mbedtls</strong></span>,
<span class="strong"><strong>-lcoap-3-wolfssl</strong></span>
or <span class="strong"><strong>-lcoap-3-tinydtls</strong></span>.   Otherwise, link with
<span class="strong"><strong>-lcoap-3</strong></span> to get the default (D)TLS library support.</p></div><div class="refsect1"><a id="_description"></a><h2>DESCRIPTION</h2><p>After setting up all the contexts, resources, endpoints sessions etc., the
underlying CoAP and (D)TLS need to send (and possible re-send) created packets
as well as receive packets for processing.</p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() function is the primary function applications should
use. There are internal functions that <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() calls which are
available to use if absolutely necessary.  These internal functions and how to
use them is different depending on whether libcoap has been compiled to use
<span class="strong"><strong>epoll</strong></span> (Linux systems only) or not.</p><p>For <span class="strong"><strong>epoll</strong></span> libcoap, <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() in simple terms calls
<span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a></strong></span>(), does an <span class="strong"><strong>epoll_wait</strong></span>() and then calls
<span class="strong"><strong><a class="st-desc" href="man_coap_io_do_epoll.html#coap_io_do_epoll" target="_self">coap_io_do_epoll</a></strong></span>() if needed to make sure that all event based i/o has been
completed.</p><p>For <span class="strong"><strong>non-epoll</strong></span> libcoap, <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() in simple terms calls
<span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a></strong></span>() to set up sockets[], sets up all of the <span class="strong"><strong>select</strong></span>()
parameters based on the COAP_SOCKET_WANT* values in the sockets[], does a
<span class="strong"><strong>select</strong></span>(), updates the sockets[] with COAP_SOCKET_CAN_* as appropriate and
then calls <span class="strong"><strong><a class="st-desc" href="man_coap_io_do_io.html#coap_io_do_io" target="_self">coap_io_do_io</a></strong></span>() to make sure that all current i/o has been
completed.</p></div><div class="refsect1"><a id="_functions"></a><h2>FUNCTIONS</h2><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() function will process any outstanding packets to send
for the specified <span class="emphasis"><em>context</em></span>, process any available input packets and then wait
for processing any new input packets, or for when to re-transmit a packet, for
up to <span class="emphasis"><em>timeout_ms</em></span> milli-seconds before returning. There are 2 special case
<span class="emphasis"><em>timeout_ms</em></span> values.</p><pre class="programlisting">#define COAP_IO_WAIT    0
#define COAP_IO_NO_WAIT ((uint32_t)-1)</pre><p>If <span class="emphasis"><em>timeout_ms</em></span> is set to COAP_IO_WAIT, then <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() will block
until the next internal action (e.g. packet retransmit) if any, or block until
the next packet is received whichever is the sooner and do the necessary
processing. If <span class="emphasis"><em>timeout_ms</em></span> is set to COAP_IO_NO_WAIT, then <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>()
will return immediately after processing without waiting for any new input
packets to arrive.</p><p><span class="strong"><strong>NOTE:</strong></span> <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() should not be called from within a callback
handler as defined using the coap_register_*_handler() as <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>()
will likely recursively call the same handler.</p><p>There are two methods of how to call <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>().</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Have <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() called from within a while() loop.  Under idle
conditions (no input traffic) <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() will then get called every
<span class="emphasis"><em>timeout_ms</em></span>, but more frequently if there is input / retransmission traffic.
</li><li class="listitem">
Wait on the file descriptor returned by <span class="strong"><strong><a class="st-desc" href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a></strong></span>()
using <span class="strong"><strong>select</strong></span>(), <span class="strong"><strong>poll</strong></span>() or an event returned by epoll_wait(). If <span class="emphasis"><em>read</em></span> is
available on the CoAP file descriptor, call <span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() with
<span class="emphasis"><em>timeout_ms</em></span> set to COAP_IO_NO_WAIT.
<span class="strong"><strong>NOTE</strong></span>: This second method is only available for environments that support epoll
(mostly Linux) with libcoap compiled to use <span class="strong"><strong>epoll</strong></span> (the default) as libcoap
will then be using <span class="strong"><strong>epoll</strong></span> internally to process all the file descriptors of
the different sessions.
</li></ol></div><p>See EXAMPLES below.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a></strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the endpoints and sessions to transmit any triggered observer
responses as well as handling any timed out packet re-transmissions.  Returned,
based on <span class="emphasis"><em>now</em></span>, is the number of milli-secs needed to delay until the next
time that <span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a></strong></span>() needs to get called.  After this call an
<span class="strong"><strong>epoll_wait</strong></span>() should done.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_do_epoll.html#coap_io_do_epoll" target="_self">coap_io_do_epoll</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_do_epoll.html#coap_io_do_epoll" target="_self">coap_io_do_epoll</a></strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the <span class="emphasis"><em>nevents</em></span> of <span class="emphasis"><em>events</em></span> returned by <span class="strong"><strong>epoll_wait</strong></span>() and
execute the appropriate low level i/o function to send / receive / process the
packets. Where appropriate, structure information (endpoints, sessions etc.)
is updated with the value of <span class="emphasis"><em>now</em></span> in the lower level functions.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a></strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will iterate
through the endpoints and sessions to add all of sockets waiting for network
traffic (COAP_SOCKET_WANT_* is set) found to <span class="emphasis"><em>sockets</em></span> (limited by
<span class="emphasis"><em>max_sockets</em></span>) and updates <span class="emphasis"><em>num_sockets</em></span> with the number of sockets found.
Furthermore, any triggered observer responses are transmitted
as well as handling any timed out packet re-transmissions.  Returned, based on
<span class="emphasis"><em>now</em></span>, is the number of milli-secs needed to delay until the next time that
<span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a></strong></span>() needs to get called.  After this call a <span class="strong"><strong>select</strong></span>() should
done on all the file descriptors (COAP_WANT_READ for readfds etc.), and any
that are returned active should set the appropriate COAP_SOCKET_CAN_* in the
<span class="emphasis"><em>sockets</em></span>.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_do_io.html#coap_io_do_io" target="_self">coap_io_do_io</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_do_io.html#coap_io_do_io" target="_self">coap_io_do_io</a></strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the endpoints and sessions to find all of sockets that have
COAP_SOCKET_CAN_* set and then execute the appropriate low level i/o function
to send / receive / process the packets. Where appropriate, structure
information (endpoints, sessions etc.) is updated with the value of <span class="emphasis"><em>now</em></span> in
the lower level functions.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a></strong></span>() function is the same as <span class="strong"><strong><a class="st-desc" href="man_coap_process_io.html#coap_process_io" target="_self">coap_process_io</a></strong></span>()
but supports additional select() style parameters <span class="emphasis"><em>nfds</em></span>, <span class="emphasis"><em>readfds</em></span>,
<span class="emphasis"><em>writefds</em></span> and <span class="emphasis"><em>exceptfds</em></span>. This provides the ability to add in additional
non libcoap FDs to test for in the internal select() call which can then
tested after the return from <a href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a>(). <span class="emphasis"><em>readfds</em></span>,
<span class="emphasis"><em>writefds</em></span> and <span class="emphasis"><em>exceptfds</em></span> can either point to a defined and pre-filled fd_set
structure or NULL if not required. <span class="emphasis"><em>nfds</em></span> needs to be set to the maximum FD to
test for in <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span> or <span class="emphasis"><em>exceptfds</em></span> if any of them are set plus 1.
If none of them are set, then <span class="emphasis"><em>nfds</em></span> should be set to 0.</p><p><span class="strong"><strong>NOTE:</strong></span> The additional parameters for <span class="strong"><strong><a class="st-desc" href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a></strong></span>() are only used
if there is no epoll support in libcoap. If there is epoll support, then
<span class="strong"><strong><a class="st-desc" href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a></strong></span>() should be used and this returned FD along with
other non libcoap FDs can separately be monitored using method 2 above.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a></strong></span>() function obtains from the specified
<span class="emphasis"><em>context</em></span> a single file descriptor that can be monitored by a <span class="strong"><strong>select</strong></span>() or
as an event returned from a <span class="strong"><strong>epoll_wait</strong></span>() call.  This file descriptor will get
updated with information (read, write etc. available) whenever any of the
internal to libcoap file descriptors (sockets) change state.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_io_pending.html#coap_io_pending" target="_self">coap_io_pending</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_io_pending.html#coap_io_pending" target="_self">coap_io_pending</a></strong></span>() function checks to see if there are any outstanding
i/o requests / responses associated with <span class="emphasis"><em>context</em></span> as well as if Observe has
been set up (client only) and large transfers are in process.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_can_exit.html#coap_can_exit" target="_self">coap_can_exit</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_can_exit.html#coap_can_exit" target="_self">coap_can_exit</a></strong></span>() function checks to see if there are any outstanding
PDUs to transmit associated with <span class="emphasis"><em>context</em></span> and returns 1 if there is nothing
outstanding else 0. This function does not check that all requests transmitted
have been responded to.</p></div><div class="refsect1"><a id="_return_values"></a><h2>RETURN VALUES</h2><p><span class="strong"><strong><a class="st-desc" href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a></strong></span>() and <span class="strong"><strong><a class="st-desc" href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a></strong></span>() return the time, in
milli-seconds, that was spent in the function. If -1 is returned, there was
an unexpected error.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a></strong></span>() returns a non-negative number as the file
descriptor to monitor, or -1 if epoll is not configured in libcoap.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_io.html#coap_io_prepare_io" target="_self">coap_io_prepare_io</a></strong></span>() and <span class="strong"><strong><a class="st-desc" href="man_coap_io_prepare_epoll.html#coap_io_prepare_epoll" target="_self">coap_io_prepare_epoll</a></strong></span>() return the number of
milli-seconds that need to be waited before the function should next be called.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_io_pending.html#coap_io_pending" target="_self">coap_io_pending</a></strong></span>() returns 1 if there is outstanding i/o else returns 0.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_can_exit.html#coap_can_exit" target="_self">coap_can_exit</a></strong></span>() returns 1 if there is nothing outstanding to transmit else
returns 0.</p></div><div class="refsect1"><a id="_examples"></a><h2>EXAMPLES</h2><p><span class="strong"><strong>Method One - use <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>()</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

int
main(int argc, char *argv[]) {

  coap_context_t *ctx = NULL;
  unsigned wait_ms;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  /* Create the libcoap context */
  ctx = <a href="man_coap_new_context.html#coap_new_context" target="_self">coap_new_context</a>(NULL);
  if (!ctx) {
    exit(1);
  }
  /* See <a href="man_coap_block.html#coap_block" target="_self">coap_block</a>(3) */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(ctx,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);


  /* Other Set up Code */

  wait_ms = COAP_RESOURCE_CHECK_TIME * 1000;

  while (1) {
    int result = <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>(ctx, wait_ms);
    if (result &lt; 0) {
      /* There is an internal issue */
      break;
    }
    /* Do any other housekeeping */
  }
  <a href="man_coap_free_context.html#coap_free_context" target="_self">coap_free_context</a>(ctx);
  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method One - coap_io_process_with_fds</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

int
main(int argc, char *argv[]) {

  coap_context_t *ctx = NULL;
  unsigned wait_ms;
  fd_set readfds;
  int nfds = 0;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  /* Create the libcoap context */
  ctx = <a href="man_coap_new_context.html#coap_new_context" target="_self">coap_new_context</a>(NULL);
  if (!ctx) {
    exit(1);
  }
  /* See <a href="man_coap_block.html#coap_block" target="_self">coap_block</a>(3) */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(ctx,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);


  FD_ZERO(&amp;readfds);
  /* Set up readfds and nfds to handle other non libcoap FDs */

  /* Other Set up Code */

  wait_ms = COAP_RESOURCE_CHECK_TIME * 1000;

  while (1) {
    int result = <a href="man_coap_io_process_with_fds.html#coap_io_process_with_fds" target="_self">coap_io_process_with_fds</a>(ctx, wait_ms, nfds, &amp;readfds, NULL, NULL);
    if (result &lt; 0) {
      /* There is an internal issue */
      break;
    }
    /* Check if set non libcoap FDs and process accordingly */

    /* Do any other housekeeping */
  }
  <a href="man_coap_free_context.html#coap_free_context" target="_self">coap_free_context</a>(ctx);
  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method Two - select() based on monitorable file descriptor</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;errno.h&gt;

int
main(int argc, char *argv[]) {

  coap_context_t *ctx = NULL;
  int coap_fd;
  fd_set m_readfds;
  int nfds;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  /* Create the libcoap context */
  ctx = <a href="man_coap_new_context.html#coap_new_context" target="_self">coap_new_context</a>(NULL);
  if (!ctx) {
    exit(1);
  }
  /* See <a href="man_coap_block.html#coap_block" target="_self">coap_block</a>(3) */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(ctx,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  coap_fd = <a href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a>(ctx);
  if (coap_fd == -1) {
    /* epoll is not supported */
    exit(1);
  }
  FD_ZERO(&amp;m_readfds);
  FD_SET(<a href="man_coap_fd.html#coap_fd" target="_self">coap_fd</a>, &amp;m_readfds);
  nfds = coap_fd + 1;

  /* Other Set up Code */

  while (1) {
    fd_set readfds = m_readfds;
    int result;
    /* Wait until any i/o takes place */
    result = select(nfds, &amp;readfds, NULL, NULL, NULL);
    if (result == -1) {
      if (errno != EAGAIN) {
        <a href="man_coap_log_debug.html#coap_log_debug" target="_self">coap_log_debug</a>("select: %s (%d)\n", <a href="man_coap_socket_strerror.html#coap_socket_strerror" target="_self">coap_socket_strerror</a>(), errno);
        break;
      }
    }
    if (result &gt; 0) {
      if (FD_ISSET(<a href="man_coap_fd.html#coap_fd" target="_self">coap_fd</a>, &amp;readfds)) {
        result = <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>(ctx, COAP_IO_NO_WAIT);
        if (result &lt; 0) {
          /* There is an internal issue */
          break;
        }
      }
    }
    /* Do any other housekeeping */
  }
  <a href="man_coap_free_context.html#coap_free_context" target="_self">coap_free_context</a>(ctx);
  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method Two - epoll_wait() based on monitorable file descriptor</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;sys/epoll.h&gt;

#include &lt;errno.h&gt;

#define MAX_EVENTS 10

int
main(int argc, char *argv[]) {

  coap_context_t *ctx = NULL;
  int coap_fd;
  int epoll_fd;
  struct epoll_event ev;
  struct epoll_event events[MAX_EVENTS];
  int nevents;
  int i;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  /* Create the libcoap context */
  ctx = <a href="man_coap_new_context.html#coap_new_context" target="_self">coap_new_context</a>(NULL);
  if (!ctx) {
    exit(1);
  }
  /* See <a href="man_coap_block.html#coap_block" target="_self">coap_block</a>(3) */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(ctx,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  coap_fd = <a href="man_coap_context_get_coap_fd.html#coap_context_get_coap_fd" target="_self">coap_context_get_coap_fd</a>(ctx);
  if (coap_fd == -1) {
    exit(1);
  }
  epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    exit(2);
  }
  ev.events = EPOLLIN;
  ev.data.fd = coap_fd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, <a href="man_coap_fd.html#coap_fd" target="_self">coap_fd</a>, &amp;ev) == -1) {
    exit(3);
  }

  /* Other Set up Code */

  while (1) {
    int result;
    /* Wait until any i/o takes place */
    nevents = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    if (nevents == -1) {
      if (errno != EAGAIN) {
        <a href="man_coap_log_debug.html#coap_log_debug" target="_self">coap_log_debug</a>("epoll_wait: %s (%d)\n", <a href="man_coap_socket_strerror.html#coap_socket_strerror" target="_self">coap_socket_strerror</a>(), errno);
        break;
      }
    }
    for (i = 0; i &lt; nevents; i++) {
      if (events[i].data.fd == coap_fd) {
        result = <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>(ctx, COAP_IO_NO_WAIT);
        if (result &lt; 0) {
          /* There is an internal issue */
          break;
        }
      } else {
        /* Process other events */
      }
    }
    /* Do any other housekeeping */
  }

  if (epoll_ctl(epoll_fd, EPOLL_CTL_DEL, <a href="man_coap_fd.html#coap_fd" target="_self">coap_fd</a>, &amp;ev) == -1) {
    <a href="man_coap_log_debug.html#coap_log_debug" target="_self">coap_log_debug</a>("epoll_ctl: %s (%d)\n", <a href="man_coap_socket_strerror.html#coap_socket_strerror" target="_self">coap_socket_strerror</a>(), errno);
  }
  <a href="man_coap_free_context.html#coap_free_context" target="_self">coap_free_context</a>(ctx);
  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();

  /* Do any other cleanup */

  exit(0);

}</pre></div><div class="refsect1"><a id="_see_also"></a><h2>SEE ALSO</h2><p><span class="strong"><strong><a class="st-desc" href="man_coap_block.html#coap_block" target="_self">coap_block</a></strong></span>(3), <span class="strong"><strong><a class="st-desc" href="man_coap_context.html#coap_context" target="_self">coap_context</a></strong></span>(3), <span class="strong"><strong><a class="st-desc" href="man_coap_init.html#coap_init" target="_self">coap_init</a></strong></span>(3) and <span class="strong"><strong><a class="st-desc" href="man_coap_supported.html#coap_supported" target="_self">coap_supported</a></strong></span>(3)</p></div><div class="refsect1"><a id="_further_information"></a><h2>FURTHER INFORMATION</h2><p>See</p><p>"<a class="ulink" href="https://rfc-editor.org/rfc/rfc7252" target="_top">RFC7252: The Constrained Application Protocol (CoAP)</a>"</p><p>for further information.</p></div><div class="refsect1"><a id="_bugs"></a><h2>BUGS</h2><p>Please raise an issue on GitHub at
<a class="ulink" href="https://github.com/obgm/libcoap/issues" target="_top">https://github.com/obgm/libcoap/issues</a> to report any bugs.</p><p>Please raise a Pull Request at <a class="ulink" href="https://github.com/obgm/libcoap/pulls" target="_top">https://github.com/obgm/libcoap/pulls</a>
for any fixes.</p></div><div class="refsect1"><a id="_authors"></a><h2>AUTHORS</h2><p>The libcoap project &lt;<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a>&gt;</p></div></div></body></html> coap_io(3)</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Sep 7 2024 00:02:05 for libcoap by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
