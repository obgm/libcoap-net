<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoap: coap_block(3)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcoap
   &#160;<span id="projectnumber">4.3.0rc2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('man_coap_block.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">coap_block(3) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>coap_block</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="idm1"></a><div class="titlepage"></div><div class="refnamediv"><h2>NAME</h2><p>coap_block, coap_context_set_block_mode, coap_add_data_large_request, coap_add_data_large_response, coap_get_data_large, coap_block_build_body, coap_send_large — Work with CoAP Blocks</p></div><div class="refsynopsisdiv"><a id="_synopsis"></a><h2>SYNOPSIS</h2><p><span class="strong"><strong>#include &lt;coap3/coap.h&gt;</strong></span></p><p><span class="strong"><strong>void coap_context_set_block_mode(coap_context_t *<span class="emphasis"><em>context</em></span>,
uint8_t <span class="emphasis"><em>block_mode</em></span>);</strong></span></p><p><span class="strong"><strong>int coap_add_data_large_request(coap_session_t *<span class="emphasis"><em>session</em></span>, coap_pdu_t *<span class="emphasis"><em>pdu</em></span>,
size_t <span class="emphasis"><em>length</em></span>, const uint8_t *<span class="emphasis"><em>data</em></span>,
coap_release_large_data_t <span class="emphasis"><em>release_func</em></span>, void *<span class="emphasis"><em>app_ptr</em></span>);</strong></span></p><p><span class="strong"><strong>int coap_add_data_large_response(coap_resource_t *<span class="emphasis"><em>resource</em></span>,
coap_session_t *<span class="emphasis"><em>session</em></span>, coap_pdu_t *<span class="emphasis"><em>request</em></span>, coap_pdu_t *<span class="emphasis"><em>response</em></span>,
const coap_binary_t *<span class="emphasis"><em>token</em></span>, const coap_string_t *query, uint16_t <span class="emphasis"><em>media_type</em></span>,
int <span class="emphasis"><em>maxage</em></span>, uint64_t etag, size_t <span class="emphasis"><em>length</em></span>, const uint8_t *<span class="emphasis"><em>data</em></span>,
coap_release_large_data_t <span class="emphasis"><em>release_func</em></span>, void *<span class="emphasis"><em>app_ptr</em></span>);</strong></span></p><p><span class="strong"><strong>int coap_get_data_large(const coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, size_t *<span class="emphasis"><em>length,
const uint8_t **_data</em></span>, size_t *<span class="emphasis"><em>offset</em></span>, size_t *<span class="emphasis"><em>total</em></span>);</strong></span></p><p><span class="strong"><strong>coap_binary_t *
coap_block_build_body(coap_binary_t *<span class="emphasis"><em>body_data</em></span>, size_t <span class="emphasis"><em>length</em></span>,
const uint8_t *<span class="emphasis"><em>data</em></span>, size_t <span class="emphasis"><em>offset</em></span>, size_t <span class="emphasis"><em>total</em></span>);</strong></span></p><p><span class="strong"><strong>coap_mid_t coap_send_large(coap_session_t *<span class="emphasis"><em>session</em></span>, coap_pdu_t *<span class="emphasis"><em>pdu</em></span>);</strong></span></p><p>For specific (D)TLS library support, link with
<span class="strong"><strong>-lcoap-3-notls</strong></span>, <span class="strong"><strong>-lcoap-3-gnutls</strong></span>,
<span class="strong"><strong>-lcoap-3-openssl</strong></span>, <span class="strong"><strong>-lcoap-3-mbedtls</strong></span>
or <span class="strong"><strong>-lcoap-3-tinydtls</strong></span>.   Otherwise, link with
<span class="strong"><strong>-lcoap-3</strong></span> to get the default (D)TLS library support.</p></div><div class="refsect1"><a id="_description"></a><h2>DESCRIPTION</h2><p>Regular setting up of a PDU and transmission is covered in coap_pdu_setup(3)
where all the payload data can fit into a single packet.  This man page covers
how to work with PDUs where the overall body of information may need to be
split across several packets by using CoAP Block-Wise Transfers (RFC 7959).</p><p>The block-wise transfers can be controlled by the application, or libcoap is
instructed to do all the requests for the next blocks and only present the
final body of the result to the application.  This man page focuses on getting
libcoap to do all the work, not how to do it all in the application.</p><p>However, if the client supplies a BLOCK1 or BLOCK2 Option in the PDU where the
block number is not 0, this is assumed to be a random access request and any
other blocks will not be requested by libcoap even if instructed otherwise.</p><p>The functions that are named <span class="strong"><strong>_large</strong></span> are intended as replacements for the
equivalent functions as described in coap_pdu_setup(3).</p><p>The <span class="strong"><strong>coap_context_set_block_mode</strong></span>() function is used to set up the <span class="emphasis"><em>context</em></span>
level <span class="emphasis"><em>block_mode</em></span> block handling bits for supporting RFC7959. <span class="emphasis"><em>block_mode</em></span>
flows down to a session when a session is created and if the peer does not
support the respective block mode, an appropriate bit may get disabled in the
session <span class="emphasis"><em>block_mode</em></span>.</p><pre class="programlisting">#define COAP_BLOCK_USE_LIBCOAP  0x01 /* Use libcoap to do block requests */
#define COAP_BLOCK_SINGLE_BODY  0x02 /* Deliver the data as a single body */</pre><p><span class="emphasis"><em>block_mode</em></span> is an or’d set of zero or more COAP_BLOCK_* definitions.</p><p>If COAP_BLOCK_SINGLE_BODY is set, then the entire body of data is presented to
the receiving handler, otherwise each individual block is presented on arrival.
To obtain the data, length and current offset, <span class="strong"><strong>coap_get_data_large</strong></span>() must
be used instead of <span class="strong"><strong>coap_get_data</strong></span>().  It may be appropriate not to set
COAP_BLOCK_SINGLE_BODY if there are RAM limitations.</p><p><span class="strong"><strong>NOTE:</strong></span> It is the responsibility of the receiving application to re-assemble
the <span class="emphasis"><em>data</em></span> as appropriate (using <span class="strong"><strong>coap_block_build_body</strong></span>()) if
COAP_BLOCK_SINGLE_BODY is not set.</p><p><span class="strong"><strong>NOTE:</strong></span> If COAP_BLOCK_SINGLE_BODY is not set, then the CoAP server on receiving
request data split over multiple blocks data must respond with 2.31 (more data
still to come), 2.01 or 2.04 (all data successfully received) as appropriate.</p><p>If COAP_BLOCK_USE_LIBCOAP is set, then any PDUs presented to the application
handlers will get the tokens set back to the initiating token so that requests
can be matched with responses even if different tokens had to be used for the
series of packet interchanges.  Furthermore, if COAP_BLOCK_SINGLE_BODY is set,
then the PDU that presents the entire body will have any BLOCKx option removed.</p><p><span class="strong"><strong>NOTE:</strong></span> COAP_BLOCK_USE_LIBCOAP must be set if libcoap is to do all the
block tracking and requesting, otherwise the application will have to do all
of this work (the default if <span class="strong"><strong>coap_context_set_block_mode</strong></span>() is not called).</p><pre class="programlisting">/**
 * Callback handler for de-allocating the data based on @p app_ptr provided to
 * coap_add_data_large_*() functions following transmission of the supplied
 * data.
 *
 * @param session The session that this data is associated with
 * @param app_ptr The application provided pointer to the
 *                coap_add_data_large_*() functions
 */
typedef void (*coap_release_large_data_t)(struct coap_session_t *session,
                                          void *app_ptr);</pre><p>The <span class="strong"><strong>coap_add_data_large_request</strong></span>() function is similar to <span class="strong"><strong>coap_add_data</strong></span>(),
but supports the transmission of data that has a body size that is potentially
larger than can be fitted into a single client request PDU. The specified
payload <span class="emphasis"><em>data</em></span> of length <span class="emphasis"><em>length</em></span> is associated with the <span class="emphasis"><em>session</em></span> with the
first block of data added to the PDU <span class="emphasis"><em>pdu</em></span> along with the appropriate CoAP
options such as BLOCK1, and SIZE1 if the data does not fit into
a single PDU.  When the block has been acknowledged by the peer, the library
will then send the next block of data until all the data has been transmitted.
This function must only be called once per <span class="emphasis"><em>pdu</em></span>.  When the final block is
transmitted, the callback function <span class="emphasis"><em>release_func</em></span> (if not NULL) with the user
defined parameter of <span class="emphasis"><em>app_ptr</em></span> is called so that the data can be released.</p><p>The <span class="strong"><strong>coap_add_data_large_response</strong></span>() function is responsible for handling
the server’s large responses to requests. <span class="strong"><strong>coap_add_data_large_response</strong></span>()
should be used as a direct replacement for <span class="strong"><strong>coap_add_data</strong></span>() if it is possible
that the <span class="emphasis"><em>length</em></span> of <span class="emphasis"><em>data</em></span> will not fit into a single server’s response pdu.
This function adds in the initial part of the payload <span class="emphasis"><em>data</em></span> of length
<span class="emphasis"><em>length</em></span> to the PDU <span class="emphasis"><em>pdu</em></span>. <span class="emphasis"><em>release_func</em></span> (if not NULL) and <span class="emphasis"><em>app_ptr</em></span> are
used for releasing the data when the body transfer is complete.  It also adds
in the appropriate CoAP options such as BLOCK2, SIZE2 and ETAG to handle
Block-Wise transfer if the data does not fit into a single PDU.
<span class="emphasis"><em>resource</em></span>, <span class="emphasis"><em>query</em></span>, <span class="emphasis"><em>session</em></span>, <span class="emphasis"><em>request</em></span>, <span class="emphasis"><em>response</em></span> and <span class="emphasis"><em>token</em></span> are the same
parameters as in the called resource handler that invokes
<span class="strong"><strong>coap_add_data_large_response</strong></span>(). If <span class="emphasis"><em>etag</em></span> is 0, then a unique ETag value will
be generated, else is the ETag value to use.
The <span class="emphasis"><em>media_type</em></span> is for the format of the <span class="emphasis"><em>data</em></span> and <span class="emphasis"><em>maxage</em></span> defines the
lifetime of the response.  If <span class="emphasis"><em>maxage</em></span> is set to -1,  then the MAXAGE option
does not get included (which indicates the default value of 60 seconds
according to RFC 7252). This function must only be called once per <span class="emphasis"><em>pdu</em></span>.
The application handler for the resource is only called once instead of
potentially multiple times.</p><p>The <span class="strong"><strong>coap_get_data_large</strong></span>() function is used abstract from the <span class="emphasis"><em>pdu</em></span>
information about the received data by updating <span class="emphasis"><em>length</em></span> with the length of
data available, <span class="emphasis"><em>data</em></span> with a pointer to where the data is located, <span class="emphasis"><em>offset</em></span>
with where this block of data starts and <span class="emphasis"><em>total</em></span> with the total amount of data.
<span class="emphasis"><em>offset</em></span> will always be zero if block_mode includes COAP_BLOCK_SINGLE_BODY.
All of the body’s data has been received if "<span class="emphasis"><em>offset</em></span> + <span class="emphasis"><em>length</em></span> == <span class="emphasis"><em>total</em></span>".</p><p><span class="strong"><strong>NOTE:</strong></span> <span class="emphasis"><em>total</em></span> is potentially only an indication of the total size of the
body and is only exact when all of the data has been received.</p><p>The <span class="strong"><strong>coap_block_build_body</strong></span>() function is used to re-assemble the received
data as returned by <span class="strong"><strong>coap_get_data_large</strong></span>() into a single blob of data. Data
from <span class="emphasis"><em>data</em></span> of length <span class="emphasis"><em>length</em></span> starting from offset <span class="emphasis"><em>offset</em></span> is added to
<span class="emphasis"><em>body_data</em></span>.  The resultant state of <span class="emphasis"><em>body_data</em></span> is returned. If <span class="emphasis"><em>body_data</em></span>
is NULL, or <span class="emphasis"><em>total</em></span> is larger than the current size of <span class="emphasis"><em>body_data</em></span>, then
<span class="emphasis"><em>body_data</em></span> is re-allocated and returned.  If there is an error, <span class="emphasis"><em>body_data</em></span>
gets de-allocated.</p><p>The <span class="strong"><strong>coap_send_large</strong></span>() function is used to initiate the transmission of a
request type <span class="emphasis"><em>pdu</em></span> associated with the <span class="emphasis"><em>session</em></span> in the same way as
<span class="strong"><strong>coap_send</strong></span>() but also sets up a mechanism for handling a (potentially) large
response of data that spans multiple blocks.  To get the start of the data
offset and total size, <span class="strong"><strong>coap_get_data_large</strong></span>() needs to be called in the
response handler. If the request includes the OBSERVE option with the observe
value set to 0, then any response that are observe triggered are also handled.</p><p>If <span class="emphasis"><em>block_mode</em></span> (as set by <span class="strong"><strong>coap_context_set_block_mode</strong></span>()) includes
COAP_BLOCK_SINGLE_BODY and <span class="strong"><strong>coap_send_large</strong></span>() is used, then the response
handler will only get called once with the entire body containing the data
from all of the individual blocks. If there is a change of data during the
blocks receipt (e.g. ETag value changes), then the entire set of data is
re-requested and the partial body dropped.</p></div><div class="refsect1"><a id="_return_values"></a><h2>RETURN VALUES</h2><p>The <span class="strong"><strong>coap_add_data_large_request</strong></span>(), <span class="strong"><strong>coap_add_data_large_response</strong></span>(), and
<span class="strong"><strong>coap_get_data_large</strong></span>() functions return 0 on failure, 1 on success.</p><p>The <span class="strong"><strong>coap_send_large</strong></span>() function returns the CoAP message ID on success or
COAP_INVALID_MID on failure.</p><p>The  <span class="strong"><strong>coap_block_build_body</strong></span>() returns the current state of the body’s data
(which may have some missing gaps) or NULL on error.</p></div><div class="refsect1"><a id="_examples"></a><h2>EXAMPLES</h2><p><span class="strong"><strong>Setup PDU and Transmit</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

static int
build_send_pdu(coap_context_t *context, coap_session_t *session,
uint8_t msgtype, uint8_t request_code, const char *uri, const char *query,
unsigned char *data, size_t length, int observe) {

  coap_pdu_t *pdu;
  uint8_t buf[1024];
  size_t buflen;
  uint8_t *sbuf = buf;
  int res;
  coap_optlist_t *optlist_chain = NULL;
  /* Remove (void) definition if variable is used */
  (void)context;

  /* Create the pdu with the appropriate options */
  pdu = coap_pdu_init(msgtype, request_code, coap_new_message_id(session),
                      coap_session_max_pdu_size(session));
  if (!pdu)
    return 0;

  /*
   * Create unique token for this request for handling unsolicited /
   * delayed responses
   */
  coap_session_new_token(session, &amp;buflen, buf);
  if (!coap_add_token(pdu, buflen, buf)) {
    coap_log(LOG_DEBUG, "cannot add token to request\n");
    goto error;
  }

  if (uri) {
    /* Add in the URI options */
    buflen = sizeof(buf);
    res = coap_split_path((const uint8_t*)uri, strlen(uri), sbuf, &amp;buflen);
    while (res--) {
      if (!coap_insert_optlist(&amp;optlist_chain,
                               coap_new_optlist(COAP_OPTION_URI_PATH,
                        coap_opt_length(sbuf), coap_opt_value(sbuf))))
        goto error;
      sbuf += coap_opt_size(sbuf);
    }
  }

  if (query) {
    /* Add in the QUERY options */
    buflen = sizeof(buf);
    res = coap_split_query((const uint8_t*)query, strlen(query), sbuf, &amp;buflen);
    while (res--) {
      if (!coap_insert_optlist(&amp;optlist_chain,
                               coap_new_optlist(COAP_OPTION_URI_QUERY,
                        coap_opt_length(sbuf), coap_opt_value(sbuf))))
        goto error;
      sbuf += coap_opt_size(sbuf);
    }
  }

  if (request_code == COAP_REQUEST_GET &amp;&amp; observe) {
    /* Indicate that we want to observe this resource */
    if (!coap_insert_optlist(&amp;optlist_chain,
                             coap_new_optlist(COAP_OPTION_OBSERVE,
                               coap_encode_var_safe(buf, sizeof(buf),
                               COAP_OBSERVE_ESTABLISH), buf)
                             ))
      goto error;
  }

  /* ... Other code / options etc. ... */

  /* Add in all the options (after internal sorting) to the pdu */
  if (!coap_add_optlist_pdu(pdu, &amp;optlist_chain))
    goto error;

  if (data &amp;&amp; length) {
    /* Add in the specified data */
    if (!coap_add_data_large_request(session, pdu, length, data, NULL, NULL))
      goto error;
  }

  if (coap_send_large(session, pdu) == COAP_INVALID_MID)
    goto error;
  return 1;

error:

  if (pdu)
    coap_delete_pdu(pdu);
  return 0;

}

int main(int argc, char *argv[]) {
  coap_context_t *context = NULL;
  coap_session_t *session = NULL;
  unsigned char *data = NULL;
  size_t data_length = 0;

  (void)argc;
  (void)argv;

  /* ... Set up context, session etc. ... */

  /* Set up using libcoap to do the block work */
  coap_context_set_block_mode(context,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  /* ... Other code etc. ... */

  /* .. build data and define data_length ... */

  build_send_pdu(context, session, COAP_MESSAGE_CON, COAP_REQUEST_PUT,
                 "/example/uri", NULL, data, data_length, 0);

  /* ... Other code etc. ... */

  return 0;
}</pre><p><span class="strong"><strong>Resource Handler Response PDU Update</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;stdio.h&gt;

static void
hnd_get_time(coap_context_t *context, coap_resource_t *resource,
coap_session_t *session, coap_pdu_t *request, coap_binary_t *token,
coap_string_t *query, coap_pdu_t *response) {

  unsigned char buf[40];
  size_t len;
  time_t now;
  /* Remove (void) definition if variable is used */
  (void)context;

  /* Note that request may be NULL if triggered by an observe response */

  /* Note that token is already in the response pdu */

  /* ... Additional analysis code for resource, request pdu etc.  ... */

  /* After analysis, generate a failure response and return if needed */

  now = time(NULL);

  if (query != NULL &amp;&amp; coap_string_equal(query, coap_make_str_const("secs"))) {
    /* Output secs since Jan 1 1970 */
    len = snprintf((char *)buf, sizeof(buf), "%lu", now);
  }
  else {
    /* Output human-readable time */
    struct tm *tmp;
    tmp = gmtime(&amp;now);
    if (!tmp) {
      /* If 'now' is not valid */
      coap_pdu_set_code(response, COAP_RESPONSE_CODE_NOT_FOUND);
      return;
    }
    len = strftime((char *)buf, sizeof(buf), "%b %d %H:%M:%S", tmp);
  }
  coap_pdu_set_code(response, COAP_RESPONSE_CODE_CONTENT);
  /*
   * Invoke coap_add_data_large_response() to do all the hard work.
   * [A good practice, even though ins this case, the amount of data is small]
   *
   * Define the format - COAP_MEDIATYPE_TEXT_PLAIN - to add in
   * Define how long this response is valid for (secs) - 1 - to add in.
   *
   * OBSERVE Option added internally if needed within the function
   * BLOCK2 Option added internally if output too large
   * SIZE2 Option added internally
   * ETAG Option added internally
   */
  coap_add_data_large_response(resource, session, request, response, token,
                               query, COAP_MEDIATYPE_TEXT_PLAIN, 1, 0,
                               len,
                               buf,
                               NULL, NULL);
}

int main(int argc, char *argv[]) {
  coap_context_t *context = NULL;
  coap_resource_t *r;

  (void)argc;
  (void)argv;

  /* ... Set up context etc. ... */

  /* Set up using libcoap to do the block work */
  coap_context_set_block_mode(context,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  /* Create a resource to return time */
  r = coap_resource_init(coap_make_str_const("time"),
                         COAP_RESOURCE_FLAGS_NOTIFY_CON);
  coap_resource_set_get_observable(r, 1);
  coap_register_handler(r, COAP_REQUEST_GET, hnd_get_time);

  /* Document resource for 'time' request */
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("0"), 0);
  coap_add_attr(r, coap_make_str_const("title"),
                coap_make_str_const("\"Internal Clock\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"secs\""),
                0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"clock\""),
                0);

  coap_add_resource(context, r);

  /* ... Loop waiting for incoming traffic ... */

}</pre></div><div class="refsect1"><a id="_see_also"></a><h2>SEE ALSO</h2><p><a href="man_coap_pdu_setup.html" target="_self"><span class="strong"><strong>coap_pdu_setup</strong></span>(3)</a>, <a href="man_coap_observe.html" target="_self"><span class="strong"><strong>coap_observe</strong></span>(3)</a>, and <a href="man_coap_resource.html" target="_self"><span class="strong"><strong>coap_resource</strong></span>(3)</a></p></div><div class="refsect1"><a id="_further_information"></a><h2>FURTHER INFORMATION</h2><p>See</p><p>"RFC7252: The Constrained Application Protocol (CoAP)"</p><p>"RFC7959: Block-Wise Transfers in the Constrained Application Protocol (CoAP)"</p><p>for further information.</p><p>See <a class="ulink" href="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#option-numbers" target="_top">https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#option-numbers</a>
for the current set of defined CoAP Options.</p></div><div class="refsect1"><a id="_bugs"></a><h2>BUGS</h2><p>Please report bugs on the mailing list for libcoap:
<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a> or raise an issue on GitHub at
<a class="ulink" href="https://github.com/obgm/libcoap/issues" target="_top">https://github.com/obgm/libcoap/issues</a></p></div><div class="refsect1"><a id="_authors"></a><h2>AUTHORS</h2><p>The libcoap project &lt;<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a>&gt;</p></div></div></body></html> coap_block(3) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 21 2021 17:29:08 for libcoap by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
