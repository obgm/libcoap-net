<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoap: coap_io(3)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcoap
   &#160;<span id="projectnumber">4.3.0rc2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('man_coap_io.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">coap_io(3) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>coap_io</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="idm1"></a><div class="titlepage"></div><div class="refnamediv"><h2>NAME</h2><p>coap_io, coap_io_process, coap_io_process_with_fds, coap_context_get_coap_fd, coap_io_prepare_io, coap_io_do_io, coap_io_prepare_epoll, coap_io_do_epoll â€” Work with CoAP I/O to do the packet send and receives</p></div><div class="refsynopsisdiv"><a id="_synopsis"></a><h2>SYNOPSIS</h2><p><span class="strong"><strong>#include &lt;coap3/coap.h&gt;</strong></span></p><p><span class="strong"><strong>int coap_io_process(coap_context_t *<span class="emphasis"><em>context</em></span>, uint32_t <span class="emphasis"><em>timeout_ms</em></span>)</strong></span>;</p><p><span class="strong"><strong>int coap_io_process_with_fds(coap_context_t *<span class="emphasis"><em>context</em></span>,
uint32_t <span class="emphasis"><em>timeout_ms</em></span>, int <span class="emphasis"><em>nfds</em></span>, fd_set *<span class="emphasis"><em>readfds</em></span>, fd_set *<span class="emphasis"><em>writefds</em></span>,
fd_set *<span class="emphasis"><em>exceptfds</em></span>)</strong></span>;</p><p><span class="strong"><strong>int coap_context_get_coap_fd(const coap_context_t *<span class="emphasis"><em>context</em></span>)</strong></span>;</p><p><span class="strong"><strong>unsigned int coap_io_prepare_io(coap_context_t *<span class="emphasis"><em>context</em></span>,
coap_socket_t *<span class="emphasis"><em>sockets</em></span>[], unsigned int <span class="emphasis"><em>max_sockets</em></span>,
unsigned int *<span class="emphasis"><em>num_sockets</em></span>, coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>void coap_io_do_io(coap_context_t *<span class="emphasis"><em>context</em></span>, coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>unsigned int coap_io_prepare_epoll(coap_context_t *<span class="emphasis"><em>context</em></span>,
coap_tick_t <span class="emphasis"><em>now</em></span>)</strong></span>;</p><p><span class="strong"><strong>void coap_io_do_epoll(coap_context_t *<span class="emphasis"><em>context</em></span>, struct epoll_event *<span class="emphasis"><em>events</em></span>,
size_t <span class="emphasis"><em>nevents</em></span>)</strong></span>;</p><p>For specific (D)TLS library support, link with
<span class="strong"><strong>-lcoap-3-notls</strong></span>, <span class="strong"><strong>-lcoap-3-gnutls</strong></span>,
<span class="strong"><strong>-lcoap-3-openssl</strong></span>, <span class="strong"><strong>-lcoap-3-mbedtls</strong></span>
or <span class="strong"><strong>-lcoap-3-tinydtls</strong></span>.   Otherwise, link with
<span class="strong"><strong>-lcoap-3</strong></span> to get the default (D)TLS library support.</p></div><div class="refsect1"><a id="_description"></a><h2>DESCRIPTION</h2><p>After setting up all the contexts, resources, endpoints sessions etc., the
underlying CoAP and (D)TLS need to send (and possible re-send) created packets
as well as receive packets for processing.</p><p>The <span class="strong"><strong>coap_io_process</strong></span>() function will process any outstanding packets to send
for the specified <span class="emphasis"><em>context</em></span>, process any available input packets and then wait
for processing any new input packets, or for when to re-transmit a packet, for
up to <span class="emphasis"><em>timeout_ms</em></span> milli-seconds before returning. There are 2 special case
<span class="emphasis"><em>timeout_ms</em></span> values.</p><pre class="programlisting">#define COAP_IO_WAIT    0
#define COAP_IO_NO_WAIT ((uint32_t)-1)</pre><p>If <span class="emphasis"><em>timeout_ms</em></span> is set to COAP_IO_WAIT, then <span class="strong"><strong>coap_io_process</strong></span>() will block
until the next internal action (e.g. packet retransmit) if any, or block until
the next packet is received whichever is the sooner and do the necessary
processing. If <span class="emphasis"><em>timeout_ms</em></span> is set to COAP_IO_NO_WAIT, then <span class="strong"><strong>coap_io_process</strong></span>()
will return immediately after processing without waiting for any new input
packets to arrive.</p><p>There are two methods of how to call <span class="strong"><strong>coap_io_process</strong></span>().</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Have <span class="strong"><strong>coap_io_process</strong></span>() called from within a while() loop.  Under idle
conditions (no input traffic) <span class="strong"><strong>coap_io_process</strong></span>() will then get called every
<span class="emphasis"><em>timeout_ms</em></span>, but more frequently if there is input / retransmission traffic.
</li><li class="listitem">
Wait on the file descriptor returned by <span class="strong"><strong>coap_context_get_coap_fd</strong></span>()
using <span class="strong"><strong>select</strong></span>() or an event returned by epoll_wait(). If <span class="emphasis"><em>read</em></span> is available on
the file descriptor, call <span class="strong"><strong>coap_io_process</strong></span>() with <span class="emphasis"><em>timeout_ms</em></span> set to
COAP_IO_NO_WAIT.
<span class="strong"><strong>NOTE</strong></span>: This second method is only available for environments that support epoll
(mostly Linux) with libcoap compiled to use <span class="strong"><strong>epoll</strong></span> (the default) as libcoap
will then be using <span class="strong"><strong>epoll</strong></span> internally to process all the file descriptors of
the different sessions.
</li></ol></div><p>See EXAMPLES below.</p><p>The <span class="strong"><strong>coap_io_process</strong></span>() function is the primary function applications should
use. There are internal functions that <span class="strong"><strong>coap_io_process</strong></span>() calls which are
available to use if absolutely necessary.  These internal functions and how to
use them is different depending on whether libcoap has been compiled to use
<span class="strong"><strong>epoll</strong></span> (Linux systems only) or not.</p><p>For <span class="strong"><strong>epoll</strong></span> libcoap, <span class="strong"><strong>coap_io_process</strong></span>() in simple terms calls
<span class="strong"><strong>coap_io_prepare_epoll()</strong></span>, does an <span class="strong"><strong>epoll_wait</strong></span>() and then calls
<span class="strong"><strong>coap_io_do_epoll</strong></span>() if needed to make sure that all event based i/o has been
completed.</p><p>For <span class="strong"><strong>non-epoll</strong></span> libcoap, <span class="strong"><strong>coap_io_process</strong></span>() in simple terms calls
<span class="strong"><strong>coap_io_prepare_io</strong></span>() to set up sockets[], sets up all of the <span class="strong"><strong>select</strong></span>()
parameters based on the COAP_SOCKET_WANT* values in the sockets[], does a
<span class="strong"><strong>select</strong></span>(), updates the sockets[] with COAP_SOCKET_CAN_* as appropriate and
then calls <span class="strong"><strong>coap_io_do_io</strong></span>() to make sure that all current i/o has been
completed.</p><p>The <span class="strong"><strong>coap_io_prepare_epoll</strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the endpoints and sessions to transmit any triggered observer
responses as well as handling any timed out packet re-transmissions.  Returned,
based on <span class="emphasis"><em>now</em></span>, is the number of milli-secs needed to delay until the next
time that <span class="strong"><strong>coap_io_prepare_epoll</strong></span>() needs to get called.  After this call an
<span class="strong"><strong>epoll_wait</strong></span>() should done.</p><p>The <span class="strong"><strong>coap_io_do_epoll</strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the <span class="emphasis"><em>nevents</em></span> of <span class="emphasis"><em>events</em></span> returned by <span class="strong"><strong>epoll_wait</strong></span>() and
execute the appropriate low level i/o function to send / receive / process the
packets. Where appropriate, structure information (endpoints, sessions etc.)
is updated with the value of <span class="emphasis"><em>now</em></span> in the lower level functions.</p><p>The <span class="strong"><strong>coap_io_prepare_io</strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will iterate
through the endpoints and sessions to add all of sockets waiting for network
traffic (COAP_SOCKET_WANT_* is set) found to <span class="emphasis"><em>sockets</em></span> (limited by
<span class="emphasis"><em>max_sockets</em></span>) and updates <span class="emphasis"><em>num_sockets</em></span> with the number of sockets found.
Furthermore, any triggered observer responses are transmitted
as well as handling any timed out packet re-transmissions.  Returned, based on
<span class="emphasis"><em>now</em></span>, is the number of milli-secs needed to delay until the next time that
<span class="strong"><strong>coap_io_prepare_io</strong></span>() needs to get called.  After this call a <span class="strong"><strong>select</strong></span>() should
done on all the file descriptors (COAP_WANT_READ for readfds etc.), and any
that are returned active should set the appropriate COAP_SOCKET_CAN_* in the
<span class="emphasis"><em>sockets</em></span>.</p><p>The <span class="strong"><strong>coap_io_do_io</strong></span>() function for the specified <span class="emphasis"><em>context</em></span> will
iterate through the endpoints and sessions to find all of sockets that have
COAP_SOCKET_CAN_* set and then execute the appropriate low level i/o function
to send / receive / process the packets. Where appropriate, structure
information (endpoints, sessions etc.) is updated with the value of <span class="emphasis"><em>now</em></span> in
the lower level functions.</p><p>The <span class="strong"><strong>coap_io_process_with_fds</strong></span>() function is the same as <span class="strong"><strong>coap_process_io</strong></span>()
but supports additional select() style parameters <span class="emphasis"><em>nfds</em></span>, <span class="emphasis"><em>readfds</em></span>,
<span class="emphasis"><em>writefds</em></span> and <span class="emphasis"><em>exceptfds</em></span>. This provides the ability to add in additional
non libcoap FDs to test for in the internal select() call which can then
tested after the return from coap_io_process_with_fds(). <span class="emphasis"><em>readfds</em></span>,
<span class="emphasis"><em>writefds</em></span> and <span class="emphasis"><em>exceptfds</em></span> can either point to a defined and pre-filled fd_set
structure or NULL if not required. <span class="emphasis"><em>nfds</em></span> needs to be set to the maximum FD to
test for in <span class="emphasis"><em>readfds</em></span>, <span class="emphasis"><em>writefds</em></span> or <span class="emphasis"><em>exceptfds</em></span> if any of them are set plus 1.
If none of them are set, then <span class="emphasis"><em>nfds</em></span> should be set to 0.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The additional parameters for <span class="strong"><strong>coap_io_process_with_fds</strong></span>() are only used
if there is no epoll support in libcoap. If there is epoll support, then
<span class="strong"><strong>coap_context_get_coap_fd</strong></span>() should be used and this returned FD along with
other non libcoap FDs can separately be monitored using method 2 above.</p></div><p>The <span class="strong"><strong>coap_context_get_coap_fd</strong></span>() function obtains from the specified
<span class="emphasis"><em>context</em></span> a single file descriptor that can be monitored by a <span class="strong"><strong>select</strong></span>() or
as an event returned from a <span class="strong"><strong>epoll_wait</strong></span>() call.  This file descriptor will get
updated with information (read, write etc. available) whenever any of the
internal to libcoap file descriptors (sockets) change state.</p></div><div class="refsect1"><a id="_return_values"></a><h2>RETURN VALUES</h2><p><span class="strong"><strong>coap_io_process</strong></span>() and <span class="strong"><strong>coap_io_process_with_fds</strong></span>() returns the time, in
milli-seconds, that was spent in the function. If -1 is returned, there was
an unexpected error.</p><p><span class="strong"><strong>coap_context_get_coap_fd</strong></span>() returns a non-negative number as the file
descriptor to monitor, or -1 if epoll is not configured in libcoap.</p><p><span class="strong"><strong>coap_io_prepare_io</strong></span>() and <span class="strong"><strong>coap_io_prepare_epoll</strong></span>() returns the number of
milli-seconds that need to be waited before the function should next be called.</p></div><div class="refsect1"><a id="_examples"></a><h2>EXAMPLES</h2><p><span class="strong"><strong>Method One - use coap_io_process()</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

int main(int argc, char *argv[]){

  coap_context_t *ctx = NULL;
  unsigned wait_ms;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Create the libcoap context */
  ctx = coap_new_context(NULL);
  if (!ctx) {
    exit(1);
  }

  /* Other Set up Code */

  wait_ms = COAP_RESOURCE_CHECK_TIME * 1000;

  while (1) {
    int result = coap_io_process(ctx, wait_ms);
    if (result &lt; 0) {
      /* There is an internal issue */
      break;
    }
    /* Do any other housekeeping */
  }
  coap_free_context(ctx);

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method One - coap_io_process_with_fds</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

int main(int argc, char *argv[]){

  coap_context_t *ctx = NULL;
  unsigned wait_ms;
  fd_set readfds;
  int nfds = 0;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Create the libcoap context */
  ctx = coap_new_context(NULL);
  if (!ctx) {
    exit(1);
  }

  FD_ZERO(&amp;readfds);
  /* Set up readfds and nfds to handle other non libcoap FDs */

  /* Other Set up Code */

  wait_ms = COAP_RESOURCE_CHECK_TIME * 1000;

  while (1) {
    int result = coap_io_process_with_fds(ctx, wait_ms, nfds, &amp;readfds, NULL, NULL);
    if (result &lt; 0) {
      /* There is an internal issue */
      break;
    }
    /* Check if set non libcoap FDs and process accordingly */

    /* Do any other housekeeping */
  }
  coap_free_context(ctx);

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method Two - select() based on monitorable file descriptor</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;errno.h&gt;

int main(int argc, char *argv[]){

  coap_context_t *ctx = NULL;
  int coap_fd;
  fd_set m_readfds;
  int nfds;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Create the libcoap context */
  ctx = coap_new_context(NULL);
  if (!ctx) {
    exit(1);
  }
  coap_fd = coap_context_get_coap_fd(ctx);
  if (coap_fd == -1) {
    /* epoll is not supported */
    exit(1);
  }
  FD_ZERO(&amp;m_readfds);
  FD_SET(coap_fd, &amp;m_readfds);
  nfds = coap_fd + 1;

  /* Other Set up Code */

  while (1) {
    fd_set readfds = m_readfds;
    int result;
    /* Wait until any i/o takes place */
    result = select (nfds, &amp;readfds, NULL, NULL, NULL);
    if (result == -1) {
      if (errno != EAGAIN) {
        coap_log(LOG_DEBUG, "select: %s (%d)\n", coap_socket_strerror(), errno);
        break;
      }
    }
    if (result &gt; 0) {
      if (FD_ISSET(coap_fd, &amp;readfds)) {
        result = coap_io_process(ctx, COAP_IO_NO_WAIT);
        if (result &lt; 0) {
          /* There is an internal issue */
          break;
        }
      }
    }
    /* Do any other housekeeping */
  }
  coap_free_context(ctx);

  /* Do any other cleanup */

  exit(0);

}</pre><p><span class="strong"><strong>Method Two - epoll_wait() based on monitorable file descriptor</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;sys/epoll.h&gt;

#include &lt;errno.h&gt;

#define MAX_EVENTS 10

int main(int argc, char *argv[]){

  coap_context_t *ctx = NULL;
  int coap_fd;
  int epoll_fd;
  struct epoll_event ev;
  struct epoll_event events[MAX_EVENTS];
  int nevents;
  int i;
  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* Create the libcoap context */
  ctx = coap_new_context(NULL);
  if (!ctx) {
    exit(1);
  }
  coap_fd = coap_context_get_coap_fd(ctx);
  if (coap_fd == -1) {
    exit(1);
  }
  epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    exit(2);
  }
  ev.events = EPOLLIN;
  ev.data.fd = coap_fd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, coap_fd, &amp;ev) == -1) {
    exit(3);
  }

  /* Other Set up Code */

  while (1) {
    int result;
    /* Wait until any i/o takes place */
    nevents = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    if (nevents == -1) {
      if (errno != EAGAIN) {
        coap_log(LOG_DEBUG, "epoll_wait: %s (%d)\n", coap_socket_strerror(), errno);
        break;
      }
    }
    for (i = 0; i &lt; nevents; i++) {
      if (events[i].data.fd == coap_fd) {
        result = coap_io_process(ctx, COAP_IO_NO_WAIT);
        if (result &lt; 0) {
          /* There is an internal issue */
          break;
        }
      }
      else {
        /* Process other events */
      }
    }
    /* Do any other housekeeping */
  }

  if (epoll_ctl(epoll_fd, EPOLL_CTL_DEL, coap_fd, &amp;ev) == -1) {
    coap_log(LOG_DEBUG, "epoll_ctl: %s (%d)\n", coap_socket_strerror(), errno);
  }
  coap_free_context(ctx);

  /* Do any other cleanup */

  exit(0);

}</pre></div><div class="refsect1"><a id="_see_also"></a><h2>SEE ALSO</h2><p><a href="man_coap_context.html" target="_self"><span class="strong"><strong>coap_context</strong></span>(3)</a></p></div><div class="refsect1"><a id="_further_information"></a><h2>FURTHER INFORMATION</h2><p>See "RFC7252: The Constrained Application Protocol (CoAP)" for further
information.</p></div><div class="refsect1"><a id="_bugs"></a><h2>BUGS</h2><p>Please report bugs on the mailing list for libcoap:
<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a> or raise an issue on GitHub at
<a class="ulink" href="https://github.com/obgm/libcoap/issues" target="_top">https://github.com/obgm/libcoap/issues</a></p></div><div class="refsect1"><a id="_authors"></a><h2>AUTHORS</h2><p>The libcoap project &lt;<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a>&gt;</p></div></div></body></html> coap_io(3) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 21 2021 17:29:08 for libcoap by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
