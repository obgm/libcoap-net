<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoap: coap_cache(3)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcoap
   &#160;<span id="projectnumber">4.3.0rc1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('man_coap_cache.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">coap_cache(3) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>coap_cache</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="idm1"></a><div class="titlepage"></div><div class="refnamediv"><h2>NAME</h2><p>coap_cache, coap_cache_derive_key, coap_cache_delete_key, coap_cache_ignore_options, coap_new_cache_entry, coap_delete_cache_entry, coap_cache_get_by_key, coap_cache_get_by_pdu, coap_cache_get_pdu â€” Work with CoAP cache functions</p></div><div class="refsynopsisdiv"><a id="_synopsis"></a><h2>SYNOPSIS</h2><p><span class="strong"><strong>#include &lt;coap2/coap.h&gt;</strong></span></p><p><span class="strong"><strong>coap_cache_key_t *coap_cache_derive_key(const coap_session_t *<span class="emphasis"><em>session</em></span>,
const coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, coap_cache_session_based_t <span class="emphasis"><em>session_based</em></span>);</strong></span></p><p><span class="strong"><strong>void coap_delete_cache_key(coap_cache_key_t *<span class="emphasis"><em>cache_key</em></span>);</strong></span></p><p><span class="strong"><strong>int coap_cache_ignore_options(coap_context_t *<span class="emphasis"><em>context</em></span>,
const uint16_t *<span class="emphasis"><em>options</em></span>, size_t <span class="emphasis"><em>count</em></span>);</strong></span></p><p><span class="strong"><strong>coap_cache_entry_t *coap_new_cache_entry(coap_session_t *<span class="emphasis"><em>session</em></span>,
const coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, coap_cache_record_pdu_t <span class="emphasis"><em>record_pdu</em></span>,
coap_cache_session_based_t <span class="emphasis"><em>session_based</em></span>, unsigned int <span class="emphasis"><em>idle_timeout</em></span>);</strong></span></p><p><span class="strong"><strong>void coap_delete_cache_entry(coap_context_t *<span class="emphasis"><em>context</em></span>,
coap_cache_entry_t *<span class="emphasis"><em>cache_entry</em></span>);</strong></span></p><p><span class="strong"><strong>coap_cache_entry_t *coap_cache_get_by_key(coap_context_t *<span class="emphasis"><em>context</em></span>,
const coap_cache_key_t *<span class="emphasis"><em>cache_key</em></span>);</strong></span></p><p><span class="strong"><strong>coap_cache_entry_t *coap_cache_get_by_pdu(coap_session_t *<span class="emphasis"><em>session</em></span>,
const coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, coap_cache_session_based_t <span class="emphasis"><em>session_based</em></span>);</strong></span></p><p><span class="strong"><strong>const coap_pdu_t *coap_cache_get_pdu(const coap_cache_entry_t *<span class="emphasis"><em>cache_entry</em></span>);</strong></span></p><p><span class="strong"><strong>void coap_cache_set_app_data(coap_cache_entry_t *<span class="emphasis"><em>cache_entry</em></span>, void *<span class="emphasis"><em>data</em></span>,
coap_cache_app_data_free_callback_t <span class="emphasis"><em>callback</em></span>);</strong></span></p><p><span class="strong"><strong>void *coap_cache_get_app_data(const coap_cache_entry_t *<span class="emphasis"><em>cache_entry</em></span>);</strong></span></p><p>Link with <span class="strong"><strong>-lcoap-2</strong></span>, <span class="strong"><strong>-lcoap-2-gnutls</strong></span>,
<span class="strong"><strong>-lcoap-2-openssl</strong></span>, <span class="strong"><strong>-lcoap-2-mbedtls</strong></span>
or <span class="strong"><strong>-lcoap-2-tinydtls</strong></span> depending on your (D)TLS library
type.</p></div><div class="refsect1"><a id="_description"></a><h2>DESCRIPTION</h2><p>The CoAP Cache provides support for two opaque objects that can be used for
tracking requests and responses.</p><p>The first is the ability to derive a Cache Key from the cacheable parts of a
CoAP PDU as defined in
<a class="ulink" href="https://tools.ietf.org/html/rfc7252#section-5.6" target="_top">https://tools.ietf.org/html/rfc7252#section-5.6</a> updated by
<a class="ulink" href="https://tools.ietf.org/html/rfc7641#section-2" target="_top">https://tools.ietf.org/html/rfc7641#section-2</a> and
<a class="ulink" href="https://tools.ietf.org/html/rfc8132#section-2" target="_top">https://tools.ietf.org/html/rfc8132#section-2</a> .</p><p>The Cache Key is a SHA256 digest if libcoap was built with TLS support,
otherwise it uses the coap_hash() function, using the information abstracted
from the PDU and (optionally) the CoAP session.</p><p>This Cache Key can then be used to match against incoming PDUs and then
appropriate action logic can take place.</p><p>There is support for excluding specific CoAP options from the Cache Key.
Examples could be to exclude CoAP BLOCK1 and BLOCK2 Options for the client or
server for ease of tracking a large PUT or GET response, but to not exclude
these CoAP options in a proxy where it makes sense to cache the individual
blocks.</p><p>The second is providing Cache Entries (which can be looked up by PDU and hence
by Cache Key) which hold additional information to make information tracking
simpler.  These Cache Entries are automatically deleted when a session closes
or a context is deleted. These Cache Entries are maintained on a hashed list
for speed of lookup.</p><p>The following enums are defined.</p><pre class="programlisting">typedef enum coap_cache_session_based_t {
  COAP_CACHE_NOT_SESSION_BASED,
  COAP_CACHE_IS_SESSION_BASED
} coap_cache_session_based_t;

typedef enum coap_cache_record_pdu_t {
  COAP_CACHE_NOT_RECORD_PDU,
  COAP_CACHE_RECORD_PDU
} coap_cache_record_pdu_t;</pre><p>The <span class="strong"><strong>coap_cache_derive_key</strong></span>() function abstracts all the non NoCacheKey CoAP
options, ignores the CoAP Observer option and includes a FETCH body from <span class="emphasis"><em>pdu</em></span>.
If <span class="emphasis"><em>session_based</em></span> is COAP_CACHE_IS_SESSION_BASED, then <span class="emphasis"><em>session</em></span> is also
included. CoAP options can be specifically ignored by the use of
<span class="strong"><strong>coap_cache_ignore_options</strong></span>().  A digest is then built from all of the
information and returned. NULL is returned on error.</p><p>The <span class="strong"><strong>coap_delete_cache_key</strong></span>() function deletes the <span class="emphasis"><em>cache_key</em></span> that was
returned from a <span class="strong"><strong>coap_cache_derive_key</strong></span>() call.</p><p>The <span class="strong"><strong>coap_cache_ignore_options</strong></span>() function is used to store in <span class="emphasis"><em>context</em></span> a
list of <span class="emphasis"><em>count</em></span> options held in <span class="emphasis"><em>options</em></span>.  The specified <span class="emphasis"><em>options</em></span> will not
be included in the data used for the <span class="strong"><strong>coap_cache_derive_key</strong></span>() function.</p><p>The <span class="strong"><strong>coap_new_cache_entry</strong></span>() function will create a new Cache Entry based on
the Cache Key derived from the <span class="emphasis"><em>pdu</em></span>, <span class="emphasis"><em>session_based</em></span> and <span class="emphasis"><em>session</em></span>. If
<span class="emphasis"><em>record_pdu</em></span> is COAP_CACHE_RECORD_PDU, then a copy of the <span class="emphasis"><em>pdu</em></span> is stored in
the Cache Entry for subsequent retrieval. The Cache Entry can also store
application specific data (<span class="strong"><strong>coap_cache_set_app_data</strong></span>() and
<span class="strong"><strong>coap_cache_get_app_data</strong></span>()).  <span class="emphasis"><em>idle_timeout</em></span> in seconds defines the length of
time not being used before it gets deleted.  If <span class="emphasis"><em>idle_timeout</em></span> is set to
0, then the Cache Entry will not get idle expired. The created Cache
Entry is returned, or NULL on error.</p><p>The <span class="strong"><strong>coap_delete_cache_entry</strong></span>() function can be used to delete the Cache Entry
<span class="emphasis"><em>cache_entry</em></span>.  This will remove the Cache Entry from the hash lookup list and
free off any internally held data.  If the Cache Entry is session based, then
it will automatically get deleted when the session is freed off or when the
idle timeout expires.</p><p>The <span class="strong"><strong>coap_cache_get_by_key</strong></span>() function will locate the Cache Entry held in the
<span class="emphasis"><em>context</em></span> environment that has Cache Key <span class="emphasis"><em>cache_key</em></span>.  Returns NULL if the
Cache Key was not found.</p><p>The <span class="strong"><strong>coap_cache_get_by_pdu</strong></span>() function will locate the Cache Entry held in the
<span class="emphasis"><em>context</em></span> environment that has a Cache Key derived from the <span class="emphasis"><em>pdu</em></span> and
whether <span class="emphasis"><em>session_based</em></span> or not.</p><p>The <span class="strong"><strong>coap_cache_get_pdu</strong></span>() function returns the PDU that was stored with the
Cache Entry when it was created with <span class="strong"><strong>coap_new_cache_entry</strong></span>() and <span class="emphasis"><em>record_pdu</em></span>
was set.  If a PDU was not initially stored, NULL is returned.
<span class="strong"><strong>NOTE:</strong></span> A copy of the returned PDU must be taken for using in sending a CoAP
packet.</p><p>The <span class="strong"><strong>coap_cache_set_app_data</strong></span>() function is used to associate <span class="emphasis"><em>data</em></span> with the
<span class="emphasis"><em>cache_entry</em></span>.  If <span class="emphasis"><em>callback</em></span> is not NULL, it points to a function to free off
<span class="emphasis"><em>data</em></span> when the <span class="emphasis"><em>cache_entry</em></span> is deleted.  If any data has been previously
stored in the <span class="emphasis"><em>cache_entry</em></span>, the pointer to the old data will get overwritten,
but the old data will not get freed off.</p><p>The <span class="emphasis"><em>callback</em></span> handler function prototype is defined as:</p><pre class="programlisting">typedef void (*coap_cache_app_data_free_callback_t)(void *data);</pre><p>where <span class="emphasis"><em>data</em></span> is passed into the callback function whenever the Cache Entry is
deleted.</p><p>The <span class="strong"><strong>coap_cache_get_app_data</strong></span>() function is used to get the previously stored
<span class="emphasis"><em>data</em></span> in the <span class="emphasis"><em>cache_entry</em></span>.</p></div><div class="refsect1"><a id="_return_values"></a><h2>RETURN VALUES</h2><p><span class="strong"><strong>coap_cache_derive_key</strong></span>() function returns a newly created Cache Key or
NULL if there is a creation failure.</p><p><span class="strong"><strong>coap_cache_ignore_options</strong></span>() function returs 1 if success, 0 on failure.</p><p><span class="strong"><strong>coap_new_cache_entry</strong></span>(), <span class="strong"><strong>coap_cache_get_by_key</strong></span>() and
<span class="strong"><strong>coap_cache_get_by_pdu</strong></span>() functions return the Cache Entry or NULL if there
is a failure.</p><p><span class="strong"><strong>coap_cache_get_pdu</strong></span>() function the PDU that is held within the Cache Entry or
NULL if there is no PDU available.</p></div><div class="refsect1"><a id="_examples"></a><h2>EXAMPLES</h2><p><span class="strong"><strong>PUT Handler supporting BLOCK1</strong></span></p><pre class="programlisting">#include &lt;coap2/coap.h&gt;

static coap_binary_t *example_data_ptr = NULL;
static int example_data_media_type = COAP_MEDIATYPE_TEXT_PLAIN;

static void
cache_free_app_data(void *data) {
  coap_binary_t *bdata = (coap_binary_t*)data;
  coap_delete_binary(bdata);
}

/*
 * Large Data PUT handler
 */

static void
hnd_put_example_data(coap_context_t *ctx,
        coap_resource_t *resource,
        coap_session_t *session,
        coap_pdu_t *request,
        coap_binary_t *token,
        coap_string_t *query,
        coap_pdu_t *response
) {
  size_t size;
  const uint8_t *data;
  coap_opt_iterator_t opt_iter;
  coap_opt_t *option;
  size_t offset;
  size_t total;
  coap_binary_t *data_so_far;

  /* Remove (void) definition if variable is used */
  (void)ctx;
  (void)token;
  (void)query;

  if (coap_get_data_large(request, &amp;size, &amp;data, &amp;offset, &amp;total) &amp;&amp;
    size != total) {
    /*
     * A part of the data has been received (COAP_BLOCK_SINGLE_BODY not set).
     * However, total unfortunately is only an indication, so it is not safe to
     * allocate a block based on total.  As per
     * https://tools.ietf.org/html/rfc7959#section-4
     *   o  In a request carrying a Block1 Option, to indicate the current
     *         estimate the client has of the total size of the resource
     *         representation, measured in bytes ("size indication").
     */
    coap_cache_entry_t *cache_entry = coap_cache_get_by_pdu(session,
                                                            request,
                                              COAP_CACHE_IS_SESSION_BASED);

    if (offset == 0) {
      if (!cache_entry) {
        /*
         * Set idle_timeout parameter to COAP_MAX_TRANSMIT_WAIT if you want
         * early removal on transmission failure. 0 means only delete when
         * the session is deleted as session_based is set here.
         */
        cache_entry = coap_new_cache_entry(session, request,
                                         COAP_CACHE_NOT_RECORD_PDU,
                                         COAP_CACHE_IS_SESSION_BASED, 0);
      }
      else {
        data_so_far = coap_cache_get_app_data(cache_entry);
        if (data_so_far) {
          coap_delete_binary(data_so_far);
          data_so_far = NULL;
        }
        coap_cache_set_app_data(cache_entry, NULL, NULL);
      }
    }
    if (!cache_entry) {
      if (offset == 0) {
        coap_log(LOG_WARNING, "Unable to create a new cache entry\n");
      }
      else {
        coap_log(LOG_WARNING,
                 "No cache entry available for the non-first BLOCK\n");
      }
      response-&gt;code = COAP_RESPONSE_CODE_INTERNAL_ERROR;
      return;
    }

    if (size) {
      /* Add in the new data to cache entry */
      data_so_far = coap_cache_get_app_data(cache_entry);
      data_so_far = coap_block_build_body(data_so_far, size, data,
                                          offset, total);
      /* Yes, data_so_far can be NULL if error */
      coap_cache_set_app_data(cache_entry, data_so_far, cache_free_app_data);
    }
    if (offset + size == total) {
      /* All the data is now in */
      data_so_far = coap_cache_get_app_data(cache_entry);
      coap_cache_set_app_data(cache_entry, NULL, NULL);
    }
    else {
      /* Give us the next block response */
      response-&gt;code = COAP_RESPONSE_CODE_CONTINUE;
      return;
    }
  }
  else {
    /* single body of data received */
    data_so_far = coap_new_binary(size);
    if (data_so_far) {
      memcpy(data_so_far-&gt;s, data, size);
    }
  }

  if (example_data_ptr) {
    /* pre-existed response */
    response-&gt;code = COAP_RESPONSE_CODE_CHANGED;
    coap_delete_binary(example_data_ptr);
  }
  else
    /* just generated response */
    response-&gt;code = COAP_RESPONSE_CODE_CREATED;

  example_data_ptr = data_so_far;
  if ((option = coap_check_option(request, COAP_OPTION_CONTENT_FORMAT,
                                  &amp;opt_iter)) != NULL) {
    example_data_media_type =
            coap_decode_var_bytes (coap_opt_value (option),
                                   coap_opt_length (option));
  }
  else {
    example_data_media_type = COAP_MEDIATYPE_TEXT_PLAIN;
  }

  response-&gt;code = COAP_RESPONSE_CODE_CHANGED;
  coap_resource_notify_observers(resource, NULL);
}

int main(int argc, char* argv[]){
  coap_context_t *ctx = NULL;  /* Set up as normal */
  /* ... */
  uint16_t cache_ignore_options[] = { COAP_OPTION_BLOCK1,
                                      COAP_OPTION_BLOCK2 };

  /* Remove (void) definition if variable is used */
  (void)argc;
  (void)argv;

  /* ... */

  /** Define the options to ignore when setting up cache-keys */
  coap_cache_ignore_options(ctx, cache_ignore_options,
             sizeof(cache_ignore_options)/sizeof(cache_ignore_options[0]));

  /* ... */

}</pre></div><div class="refsect1"><a id="_see_also"></a><h2>SEE ALSO</h2><p><a href="man_coap_block.html" target="_self"><span class="strong"><strong>coap_block</strong></span>(3)</a>, <a href="man_coap_pdu_setup.html" target="_self"><span class="strong"><strong>coap_pdu_setup</strong></span>(3)</a>, <a href="man_coap_resource.html" target="_self"><span class="strong"><strong>coap_resource</strong></span>(3)</a> and <a href="man_coap_string.html" target="_self"><span class="strong"><strong>coap_string</strong></span>(3)</a></p></div><div class="refsect1"><a id="_further_information"></a><h2>FURTHER INFORMATION</h2><p>See</p><p>"RFC7252: The Constrained Application Protocol (CoAP)"</p><p>"RFC7959: Block-Wise Transfers in the Constrained Application Protocol (CoAP)"</p><p>for further information.</p></div><div class="refsect1"><a id="_bugs"></a><h2>BUGS</h2><p>Please report bugs on the mailing list for libcoap:
<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a> or raise an issue on GitHub at
<a class="ulink" href="https://github.com/obgm/libcoap/issues" target="_top">https://github.com/obgm/libcoap/issues</a></p></div><div class="refsect1"><a id="_authors"></a><h2>AUTHORS</h2><p>The libcoap project &lt;<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a>&gt;</p></div></div></body></html> coap_cache(3) </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 18 2021 15:05:42 for libcoap by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
