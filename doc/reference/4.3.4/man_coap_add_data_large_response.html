<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcoap: coap_add_data_large_response(3)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcoap<span id="projectnumber">&#160;4.3.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('man_coap_add_data_large_response.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">coap_add_data_large_response(3) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>coap_block</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /></head><body><div xml:lang="en" class="refentry" lang="en"><a id="idm1"></a><div class="titlepage"></div><div class="refnamediv"><h2>NAME</h2><p><a href="man_coap_block.html#coap_block" target="_self">coap_block</a>, <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>, <a href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>, <a href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a>, <a href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a>, <a href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a>, <a href="man_coap_q_block_is_supported.html#coap_q_block_is_supported" target="_self">coap_q_block_is_supported</a> - Work with CoAP Blocks </p></div><div class="refsynopsisdiv"><a id="_synopsis"></a><h2>SYNOPSIS</h2><p><span class="strong"><strong>#include &lt;coap3/coap.h&gt;</strong></span></p><p><span class="strong"><strong>void <a class="st-synopsis" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(coap_context_t *<span class="emphasis"><em>context</em></span>,
uint8_t <span class="emphasis"><em>block_mode</em></span>);</strong></span></p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>(coap_session_t *<span class="emphasis"><em>session</em></span>,
coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, size_t <span class="emphasis"><em>length</em></span>, const uint8_t *<span class="emphasis"><em>data</em></span>,
coap_release_large_data_t <span class="emphasis"><em>release_func</em></span>, void *<span class="emphasis"><em>app_ptr</em></span>);</strong></span></p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a>(coap_resource_t *<span class="emphasis"><em>resource</em></span>,
coap_session_t *<span class="emphasis"><em>session</em></span>, const coap_pdu_t *<span class="emphasis"><em>request</em></span>, coap_pdu_t *<span class="emphasis"><em>response</em></span>,
const coap_string_t *query, uint16_t <span class="emphasis"><em>media_type</em></span>, int <span class="emphasis"><em>maxage</em></span>,
uint64_t etag, size_t <span class="emphasis"><em>length</em></span>, const uint8_t *<span class="emphasis"><em>data</em></span>,
coap_release_large_data_t <span class="emphasis"><em>release_func</em></span>, void *<span class="emphasis"><em>app_ptr</em></span>);</strong></span></p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a>(const coap_pdu_t *<span class="emphasis"><em>pdu</em></span>, size_t *<span class="emphasis"><em>length,
const uint8_t **_data</em></span>, size_t *<span class="emphasis"><em>offset</em></span>, size_t *<span class="emphasis"><em>total</em></span>);</strong></span></p><p><span class="strong"><strong>coap_binary_t *<a class="st-synopsis" href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a>(coap_binary_t *<span class="emphasis"><em>body_data</em></span>,
size_t <span class="emphasis"><em>length</em></span>, const uint8_t *<span class="emphasis"><em>data</em></span>, size_t <span class="emphasis"><em>offset</em></span>, size_t <span class="emphasis"><em>total</em></span>);</strong></span></p><p><span class="strong"><strong>int <a class="st-synopsis" href="man_coap_q_block_is_supported.html#coap_q_block_is_supported" target="_self">coap_q_block_is_supported</a>(void);</strong></span></p><p>For specific (D)TLS library support, link with
<span class="strong"><strong>-lcoap-3-notls</strong></span>, <span class="strong"><strong>-lcoap-3-gnutls</strong></span>,
<span class="strong"><strong>-lcoap-3-openssl</strong></span>, <span class="strong"><strong>-lcoap-3-mbedtls</strong></span>
or <span class="strong"><strong>-lcoap-3-tinydtls</strong></span>.   Otherwise, link with
<span class="strong"><strong>-lcoap-3</strong></span> to get the default (D)TLS library support.</p></div><div class="refsect1"><a id="_description"></a><h2>DESCRIPTION</h2><p>Regular setting up of a PDU and transmission is covered in <span class="strong"><strong><a class="st-desc" href="man_coap_pdu_setup.html#coap_pdu_setup" target="_self">coap_pdu_setup</a></strong></span>(3)
where all the payload data can fit in a single packet.  This man page covers
how to work with PDUs where the overall body of information may need to be
split across several packets by using CoAP Block-Wise Transfers
(<a class="ulink" href="https://rfc-editor.org/rfc/rfc7959" target="_top">RFC7959</a> and
<a class="ulink" href="https://rfc-editor.org/rfc/rfc9177" target="_top">RFC9177</a>).</p><p>The block-wise transfers can be controlled by the application, or libcoap is
instructed to do all the requests for the next blocks and only present the
final body of the result to the application.  In summary, the following three
ways handle processing a body of data that has to be split across multiple
payloads (blocks).</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Application does all the work
It is the responsibility of the application to analyze each block transmission
at receipt and then generate the next request as per
<a class="ulink" href="https://rfc-editor.org/rfc/rfc7959" target="_top">RFC7959</a>.  In this case,
<span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a></strong></span>() function must not be called to maintain
backward compatibility with applications that did the block handling within the
application.
</li><li class="listitem">
Application sees individual blocks
By calling <span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(context, COAP_BLOCK_USE_LIBCOAP)</strong></span> and
using the appropriate functions, the requests for the next block of data is
handled automatically by the libcoap layer.  Each individual block of data is
presented to the application for processing.
By calling <span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>(), the application can determine if this is
the first block or not (using <span class="emphasis"><em>offset</em></span> value), whether the first block is all
the data (<span class="emphasis"><em>offset</em></span> = 0, <span class="emphasis"><em>length</em></span> = <span class="emphasis"><em>total</em></span>) and whether this is the last block
(<span class="emphasis"><em>offset</em></span> + <span class="emphasis"><em>length</em></span> = <span class="emphasis"><em>total</em></span>). It is the responsibility of the application to
re-assemble the individual blocks into a single body of data.
<span class="strong"><strong>NOTE:</strong></span> <span class="emphasis"><em>total</em></span> is only an approximation (it will be &gt; <span class="emphasis"><em>offset</em></span> + <span class="emphasis"><em>length</em></span>)
until the final block is received.
If this is the request handler in a server, the server still needs to return a
COAP_RESPONSE_CODE_CONTINUE 2.31 (Continue) response code if the received data
is not for the final block, otherwise a COAP_RESPONSE_CODE_CREATED 2.01
(Created) or COAP_RESPONSE_CODE_CHANGED 2.04 (Changed) should be returned.
</li><li class="listitem">
Application only sees all of the body
By calling <span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(context,
COAP_BLOCK_USE_LIBCOAP|COAP_BLOCK_SINGLE_BODY)</strong></span> and using the appropriate
functions, the requests for all the blocks of data is handled automatically by
the libcoap layer.  Only the complete body of the data is presented to the
application, unless there is an error.
<span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>() will only return the entire body of data (<span class="emphasis"><em>offset</em></span>
always 0, <span class="emphasis"><em>length</em></span> = <span class="emphasis"><em>total</em></span>) and there is no need to re-assemble individual
blocks into a large body of data.
In RAM constrained environments, option 2 may be the preferred method.
</li></ol></div><p>This man page focuses on getting libcoap to do all the work, not how to do it
all in the application.</p><p>However, if the client supplies a Block1 or Block2 Option in the PDU where the
block number is not 0, this is assumed to be a random access request and any
other blocks will not be requested by libcoap even if instructed otherwise.</p><p>The functions that are named <span class="strong"><strong>_large</strong></span> are intended as replacements for the
equivalent functions as described in <span class="strong"><strong><a class="st-desc" href="man_coap_pdu_setup.html#coap_pdu_setup" target="_self">coap_pdu_setup</a></strong></span>(3).</p></div><div class="refsect1"><a id="_callback_handler"></a><h2>CALLBACK HANDLER</h2><p><span class="strong"><strong>Callback Type: coap_release_large_data_t</strong></span></p><pre class="programlisting">/**
 * Callback handler for de-allocating the data based on @p app_ptr provided to
 * coap_add_data_large_*() functions following transmission of the supplied
 * data.
 *
 * @param session The session that this data is associated with
 * @param app_ptr The application provided pointer to the
 *                coap_add_data_large_*() functions
 */
typedef void (*coap_release_large_data_t)(coap_session_t *session,
                                          void *app_ptr);</pre></div><div class="refsect1"><a id="_functions"></a><h2>FUNCTIONS</h2><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a></strong></span>() function is used to set up the <span class="emphasis"><em>context</em></span>
level <span class="emphasis"><em>block_mode</em></span> block handling bits for supporting
<a class="ulink" href="https://rfc-editor.org/rfc/rfc7959" target="_top">RFC7959</a> <span class="emphasis"><em>block_mode</em></span>
flows down to a session when a session is created and if the peer does not
support the respective block mode, an appropriate bit may get disabled in the
session <span class="emphasis"><em>block_mode</em></span>.</p><pre class="programlisting">#define COAP_BLOCK_USE_LIBCOAP   0x01 /* Use libcoap to do block requests */
#define COAP_BLOCK_SINGLE_BODY   0x02 /* Deliver the data as a single body */
#define COAP_BLOCK_TRY_Q_BLOCK   0x04 /* Try Q-Block method */
#define COAP_BLOCK_USE_M_Q_BLOCK 0x08 /* Use M bit when recovering Q-Block2 */
#define COAP_BLOCK_NO_PREEMPTIVE_RTAG 0x10 /* Don't use pre-emptive Request-Tags */</pre><p><span class="emphasis"><em>block_mode</em></span> is an or’d set of zero or more COAP_BLOCK_* definitions.</p><p>If <span class="strong"><strong>COAP_BLOCK_USE_LIBCOAP</strong></span> is not set, then everything works as per Option 1
above.</p><p>If <span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> is set, then the entire body of data is presented to
the receiving handler, otherwise each individual block is presented on arrival.
To obtain the data, length and current offset, <span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>() must
be used instead of <span class="strong"><strong><a class="st-desc" href="man_coap_get_data.html#coap_get_data" target="_self">coap_get_data</a></strong></span>().  It may be appropriate not to set
<span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> if there are RAM limitations.</p><p><span class="strong"><strong>NOTE:</strong></span> It is the responsibility of the receiving application to re-assemble
the <span class="emphasis"><em>data</em></span> as appropriate (e.g., using <span class="strong"><strong><a class="st-desc" href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a></strong></span>()) if
<span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> is not set.</p><p><span class="strong"><strong>NOTE:</strong></span> If <span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> is not set, then the CoAP server on
receiving
request data that is split over multiple data blocks must respond with
COAP_RESPONSE_CODE_CONTINUE 2.31 (Continue) response code if the received data
is not for the final block, otherwise a COAP_RESPONSE_CODE_CREATED 2.01
(Created) or COAP_RESPONSE_CODE_CHANGED 2.04 (Changed) should be returned.</p><p>To indicate support for Q-Block-1 and Q-Block2, <span class="strong"><strong>COAP_BLOCK_TRY_Q_BLOCK</strong></span> needs
to be set on both the client and server.  <span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> is assumed to
be set if using Q-Block as the data will always be presented as a single body.
If <span class="strong"><strong>COAP_BLOCK_USE_M_Q_BLOCK</strong></span> is defined, then the <span class="emphasis"><em>M</em></span> bit version of recovery
will be used if possible.</p><p>If <span class="strong"><strong>COAP_BLOCK_USE_LIBCOAP</strong></span> is set, then any PDUs presented to the application
handlers will get the tokens set back to the initiating token so that requests
can be matched with responses even if different tokens had to be used for the
series of packet interchanges.  Furthermore, if <span class="strong"><strong>COAP_BLOCK_SINGLE_BODY</strong></span> is set,
then the PDU that presents the entire body will have any BlockX or Q-BlockX
option removed.</p><p><span class="strong"><strong>NOTE:</strong></span> <span class="strong"><strong>COAP_BLOCK_USE_LIBCOAP</strong></span> must be set if libcoap is to do all the
block tracking and requesting, otherwise the application will have to do all
of this work (the default if <span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a></strong></span>() is not called).</p><p>If <span class="strong"><strong>COAP_BLOCK_NO_PREEMPTIVE_RTAG</strong></span> is set, then Request-Tag options are only
sent when a large amount of data is being sent to the server using the Block1
option.  Otherwise, a Request-Tag option is sent with any request (apart from
DELETE) on the off chance that there may be multiple Block2 based
responses for multiple requests to the same resource that need to be
differentiated between.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a></strong></span>() function is similar to <span class="strong"><strong><a class="st-desc" href="man_coap_add_data.html#coap_add_data" target="_self">coap_add_data</a></strong></span>(),
but supports the transmission of data that has a body size that is potentially
larger than can be fitted into a single client request PDU. The specified
payload <span class="emphasis"><em>data</em></span> of length <span class="emphasis"><em>length</em></span> is associated with the <span class="emphasis"><em>session</em></span> with the
first block of data added to the PDU <span class="emphasis"><em>pdu</em></span> along with the appropriate CoAP
options such as (Q-)Block1, Size1 and Request-Tag if the data does not fit in
a single PDU.</p><p>When the block receipt has been acknowledged by the peer, the library
will then send the next block of data until all the data has been transmitted.</p><p>The <span class="emphasis"><em>data</em></span> passed to the
function <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a></strong></span>() must exist until all blocks have been
transmitted. The callback function <span class="emphasis"><em>release_func</em></span> can be used to release
storage that has been dynamically allocated to hold the transmit data. If not
NULL, the callback function is called once the final block of <span class="emphasis"><em>data</em></span> has been
transmitted. The user-defined parameter <span class="emphasis"><em>app_ptr</em></span> is the same value that was
passed to <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a></strong></span>().</p><p><span class="strong"><strong>NOTE:</strong></span> This function must only be called once per <span class="emphasis"><em>pdu</em></span>.</p><p><span class="strong"><strong>NOTE:</strong></span> Options cannot be added to the <span class="emphasis"><em>pdu</em></span> after
<a href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>() is called.</p><p><span class="strong"><strong><a class="anchor" id="coap_add_data_large_response"></a>Function: <a href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>() function is responsible for handling
the server’s large responses to requests. <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>()
should be used as a direct replacement for <span class="strong"><strong><a class="st-desc" href="man_coap_add_data.html#coap_add_data" target="_self">coap_add_data</a></strong></span>() if it is possible
that the <span class="emphasis"><em>length</em></span> of <span class="emphasis"><em>data</em></span> will not fit in a single server’s response pdu.
This function adds in the initial part of the payload <span class="emphasis"><em>data</em></span> of length
<span class="emphasis"><em>length</em></span> to the PDU <span class="emphasis"><em>pdu</em></span>.</p><p>The <span class="emphasis"><em>data</em></span> passed to the function
<span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>() must exist until all blocks have been
transmitted. The callback function <span class="emphasis"><em>release_func</em></span> can be used to release
storage that has been dynamically allocated to hold the transmit data. If not
NULL, the callback function is called once the final block of <span class="emphasis"><em>data</em></span> has been
transmitted. The user-defined parameter <span class="emphasis"><em>app_ptr</em></span> is the same value that was
passed to <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>().</p><p>It also adds in the appropriate CoAP options such as Block2, Size2 and ETag to
handle block-wise transfer if the data does not fit in a single PDU.</p><p><span class="emphasis"><em>resource</em></span>, <span class="emphasis"><em>query</em></span>, <span class="emphasis"><em>session</em></span>, <span class="emphasis"><em>request</em></span>, and <span class="emphasis"><em>response</em></span> are the same
parameters as in the called resource handler that invokes
<span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>(). If <span class="emphasis"><em>etag</em></span> is 0, then a unique ETag value will
be generated, else is the ETag value to use.
The <span class="emphasis"><em>media_type</em></span> is for the format of the <span class="emphasis"><em>data</em></span> and <span class="emphasis"><em>maxage</em></span> defines the
lifetime of the response.  If <span class="emphasis"><em>maxage</em></span> is set to -1,  then the Max-Age option
does not get included (which indicates the default value of 60 seconds
according to
"<a class="ulink" href="https://rfc-editor.org/rfc/rfc7252#section-5.6.1" target="_top">RFC7252 5.6.1. Freshness
Model</a>").</p><p>The application request handler for the resource is only called once instead of
potentially multiple times.</p><p><span class="strong"><strong>NOTE:</strong></span> This function must only be called once per <span class="emphasis"><em>pdu</em></span>.</p><p><span class="strong"><strong>NOTE:</strong></span> Options cannot be added to the <span class="emphasis"><em>pdu</em></span> after
<a href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>() is called.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>() function is used abstract from the <span class="emphasis"><em>pdu</em></span>
information about the received data by updating <span class="emphasis"><em>length</em></span> with the length of
data available, <span class="emphasis"><em>data</em></span> with a pointer to where the data is located, <span class="emphasis"><em>offset</em></span>
with where this block of data starts and <span class="emphasis"><em>total</em></span> with the total amount of data.
<span class="emphasis"><em>offset</em></span> will always be zero if block_mode includes COAP_BLOCK_SINGLE_BODY.
All of the body’s data has been received if "<span class="emphasis"><em>offset</em></span> + <span class="emphasis"><em>length</em></span> == <span class="emphasis"><em>total</em></span>".</p><p><span class="strong"><strong>NOTE:</strong></span> <span class="emphasis"><em>total</em></span> is potentially only an indication of the total size of the
body and is only exact when all of the data has been received.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a></strong></span>() function is used to re-assemble the received
data as returned by <span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>() into a single blob of data. Data
from <span class="emphasis"><em>data</em></span> of length <span class="emphasis"><em>length</em></span> starting from offset <span class="emphasis"><em>offset</em></span> is added to
<span class="emphasis"><em>body_data</em></span>.  The resultant state of <span class="emphasis"><em>body_data</em></span> is returned. If <span class="emphasis"><em>body_data</em></span>
is NULL, or <span class="emphasis"><em>total</em></span> is larger than the current size of <span class="emphasis"><em>body_data</em></span>, then
<span class="emphasis"><em>body_data</em></span> is re-allocated and returned.  If there is an error, <span class="emphasis"><em>body_data</em></span>
gets de-allocated.</p><p>If <span class="emphasis"><em>block_mode</em></span> (as set by <span class="strong"><strong><a class="st-desc" href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a></strong></span>()) includes
COAP_BLOCK_SINGLE_BODY, then the request/response handler will only get called
once with the entire body containing the data from all of the individual
blocks. If there is a change of data during the blocks receipt (e.g., ETag
value changes), then the entire set of data is re-requested and the partial
body dropped.</p><p><span class="strong"><strong>Function: <a class="st-desc" href="man_coap_q_block_is_supported.html#coap_q_block_is_supported" target="_self">coap_q_block_is_supported</a>()</strong></span></p><p>The <span class="strong"><strong><a class="st-desc" href="man_coap_q_block_is_supported.html#coap_q_block_is_supported" target="_self">coap_q_block_is_supported</a></strong></span>() function is used to determine whether
libcoap has been build with Q-Block support or not.</p></div><div class="refsect1"><a id="_return_values"></a><h2>RETURN VALUES</h2><p><span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a></strong></span>(), <span class="strong"><strong><a class="st-desc" href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a></strong></span>(), and
<span class="strong"><strong><a class="st-desc" href="man_coap_get_data_large.html#coap_get_data_large" target="_self">coap_get_data_large</a></strong></span>() return 0 on failure, 1 on success.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_block_build_body.html#coap_block_build_body" target="_self">coap_block_build_body</a></strong></span>() returns the current state of the body’s data
(which may have some missing gaps) or NULL on error.</p><p><span class="strong"><strong><a class="st-desc" href="man_coap_q_block_is_supported.html#coap_q_block_is_supported" target="_self">coap_q_block_is_supported</a></strong></span>() returns 0 on failure, 1 on success.</p></div><div class="refsect1"><a id="_examples"></a><h2>EXAMPLES</h2><p><span class="strong"><strong>Setup PDU and Transmit</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

static int
build_send_pdu(coap_context_t *context, coap_session_t *session,
uint8_t msgtype, uint8_t request_code, const char *uri, const char *query,
unsigned char *data, size_t length, int observe) {

  coap_pdu_t *pdu;
  uint8_t buf[1024];
  size_t buflen;
  uint8_t *sbuf = buf;
  int res;
  coap_optlist_t *optlist_chain = NULL;
  /* Remove (void) definition if variable is used */
  (void)context;

  /* Create the pdu with the appropriate options */
  pdu = <a href="man_coap_pdu_init.html#coap_pdu_init" target="_self">coap_pdu_init</a>(msgtype, request_code, <a href="man_coap_new_message_id.html#coap_new_message_id" target="_self">coap_new_message_id</a>(session),
                      <a href="man_coap_session_max_pdu_size.html#coap_session_max_pdu_size" target="_self">coap_session_max_pdu_size</a>(session));
  if (!pdu)
    return 0;

  /*
   * Create unique token for this request for handling unsolicited /
   * delayed responses
   */
  <a href="man_coap_session_new_token.html#coap_session_new_token" target="_self">coap_session_new_token</a>(session, &amp;buflen, buf);
  if (!<a href="man_coap_add_token.html#coap_add_token" target="_self">coap_add_token</a>(pdu, buflen, buf)) {
    <a href="man_coap_log_debug.html#coap_log_debug" target="_self">coap_log_debug</a>("cannot add token to request\n");
    goto error;
  }

  if (uri) {
    /* Add in the URI options */
    buflen = sizeof(buf);
    res = <a href="man_coap_split_path.html#coap_split_path" target="_self">coap_split_path</a>((const uint8_t*)uri, strlen(uri), sbuf, &amp;buflen);
    while (res--) {
      if (!<a href="man_coap_insert_optlist.html#coap_insert_optlist" target="_self">coap_insert_optlist</a>(&amp;optlist_chain,
                               <a href="man_coap_new_optlist.html#coap_new_optlist" target="_self">coap_new_optlist</a>(COAP_OPTION_URI_PATH,
                        <a href="man_coap_opt_length.html#coap_opt_length" target="_self">coap_opt_length</a>(sbuf), <a href="man_coap_opt_value.html#coap_opt_value" target="_self">coap_opt_value</a>(sbuf))))
        goto error;
      sbuf += <a href="man_coap_opt_size.html#coap_opt_size" target="_self">coap_opt_size</a>(sbuf);
    }
  }

  if (query) {
    /* Add in the QUERY options */
    buflen = sizeof(buf);
    res = <a href="man_coap_split_query.html#coap_split_query" target="_self">coap_split_query</a>((const uint8_t*)query, strlen(query), sbuf, &amp;buflen);
    while (res--) {
      if (!<a href="man_coap_insert_optlist.html#coap_insert_optlist" target="_self">coap_insert_optlist</a>(&amp;optlist_chain,
                               <a href="man_coap_new_optlist.html#coap_new_optlist" target="_self">coap_new_optlist</a>(COAP_OPTION_URI_QUERY,
                        <a href="man_coap_opt_length.html#coap_opt_length" target="_self">coap_opt_length</a>(sbuf), <a href="man_coap_opt_value.html#coap_opt_value" target="_self">coap_opt_value</a>(sbuf))))
        goto error;
      sbuf += <a href="man_coap_opt_size.html#coap_opt_size" target="_self">coap_opt_size</a>(sbuf);
    }
  }

  if (request_code == COAP_REQUEST_GET &amp;&amp; observe) {
    /* Indicate that we want to observe this resource */
    if (!<a href="man_coap_insert_optlist.html#coap_insert_optlist" target="_self">coap_insert_optlist</a>(&amp;optlist_chain,
                             <a href="man_coap_new_optlist.html#coap_new_optlist" target="_self">coap_new_optlist</a>(COAP_OPTION_OBSERVE,
                               <a href="man_coap_encode_var_safe.html#coap_encode_var_safe" target="_self">coap_encode_var_safe</a>(buf, sizeof(buf),
                               COAP_OBSERVE_ESTABLISH), buf)
                             ))
      goto error;
  }

  /* ... Other code / options etc. ... */

  /* Add in all the options (after internal sorting) to the pdu */
  if (!<a href="man_coap_add_optlist_pdu.html#coap_add_optlist_pdu" target="_self">coap_add_optlist_pdu</a>(pdu, &amp;optlist_chain))
    goto error;

  if (data &amp;&amp; length) {
    /* Add in the specified data */
    if (!<a href="man_coap_add_data_large_request.html#coap_add_data_large_request" target="_self">coap_add_data_large_request</a>(session, pdu, length, data, NULL, NULL))
      goto error;
  }

  if (<a href="man_coap_send.html#coap_send" target="_self">coap_send</a>(session, pdu) == COAP_INVALID_MID)
    goto error;
  return 1;

error:

  if (pdu)
    <a href="man_coap_delete_pdu.html#coap_delete_pdu" target="_self">coap_delete_pdu</a>(pdu);
  return 0;

}

int
main(int argc, char *argv[]) {
  coap_context_t *context = NULL;
  coap_session_t *session = NULL;
  unsigned char *data = NULL;
  size_t data_length = 0;

  (void)argc;
  (void)argv;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  /* ... Set up context, session etc. ... */

  /* Set up using libcoap to do the block work */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(context,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  /* ... Other code etc. ... */

  /* .. build data and define data_length ... */

  build_send_pdu(context, session, COAP_MESSAGE_CON, COAP_REQUEST_PUT,
                 "/example/uri", NULL, data, data_length, 0);

  /* ... Other code etc. ... */

  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();
  return 0;
}</pre><p><span class="strong"><strong>Resource Request Handler Response PDU Update</strong></span></p><pre class="programlisting">#include &lt;coap3/coap.h&gt;

#include &lt;stdio.h&gt;

static void
hnd_get_time(coap_resource_t *resource, coap_session_t *session,
const coap_pdu_t *request, const coap_string_t *query, coap_pdu_t *response) {

  unsigned char buf[40];
  size_t len;
  time_t now;

  /* ... Additional analysis code for resource, request pdu etc.  ... */

  /* After analysis, generate a failure response and return if needed */

  now = time(NULL);

  if (query != NULL &amp;&amp; <a href="man_coap_string_equal.html#coap_string_equal" target="_self">coap_string_equal</a>(query, <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("secs"))) {
    /* Output secs since Jan 1 1970 */
    len = snprintf((char *)buf, sizeof(buf), "%lu", now);
  }
  else {
    /* Output human-readable time */
    struct tm *tmp;
    tmp = gmtime(&amp;now);
    if (!tmp) {
      /* If 'now' is not valid */
      <a href="man_coap_pdu_set_code.html#coap_pdu_set_code" target="_self">coap_pdu_set_code</a>(response, COAP_RESPONSE_CODE_NOT_FOUND);
      return;
    }
    len = strftime((char *)buf, sizeof(buf), "%b %d %H:%M:%S", tmp);
  }
  <a href="man_coap_pdu_set_code.html#coap_pdu_set_code" target="_self">coap_pdu_set_code</a>(response, COAP_RESPONSE_CODE_CONTENT);
  /*
   * Invoke <a href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a>() to do all the hard work.
   * [A good practice, even though ins this case, the amount of data is small]
   *
   * Define the format - COAP_MEDIATYPE_TEXT_PLAIN - to add in
   * Define how long this response is valid for (secs) - 1 - to add in.
   *
   * Observe Option added internally if needed within the function
   * Block2 Option added internally if output too large
   * Size2 Option added internally
   * ETag Option added internally
   */
  <a href="man_coap_add_data_large_response.html#coap_add_data_large_response" target="_self"><span class="man-highlight">coap_add_data_large_response</span></a>(resource, session, request, response,
                               query, COAP_MEDIATYPE_TEXT_PLAIN, 1, 0,
                               len,
                               buf,
                               NULL, NULL);
  /*
   * When request handler returns, the response pdu will get automatically
   * sent, unless the pdu code is not updated and this is a NON or TCP based
   * request.
   */
}

int
main(int argc, char *argv[]) {
  coap_context_t *context = NULL;
  coap_resource_t *r;
  coap_resource_t *time_resource;
  int not_exit = 1;

  /* Initialize libcoap library */
  <a href="man_coap_startup.html#coap_startup" target="_self">coap_startup</a>();

  (void)argc;
  (void)argv;

  /* ... Set up context etc. ... */

  /* Set up using libcoap to do the block work */
  <a href="man_coap_context_set_block_mode.html#coap_context_set_block_mode" target="_self">coap_context_set_block_mode</a>(context,
                              COAP_BLOCK_USE_LIBCOAP | COAP_BLOCK_SINGLE_BODY);

  /* Create a resource to return time */
  r = <a href="man_coap_resource_init.html#coap_resource_init" target="_self">coap_resource_init</a>(<a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("time"),
                         COAP_RESOURCE_FLAGS_NOTIFY_CON);
  <a href="man_coap_resource_set_get_observable.html#coap_resource_set_get_observable" target="_self">coap_resource_set_get_observable</a>(r, 1);
  <a href="man_coap_register_request_handler.html#coap_register_request_handler" target="_self">coap_register_request_handler</a>(r, COAP_REQUEST_GET, hnd_get_time);

  /* Document resource for 'time' request */
  <a href="man_coap_add_attr.html#coap_add_attr" target="_self">coap_add_attr</a>(r, <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("ct"), <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("0"), 0);
  <a href="man_coap_add_attr.html#coap_add_attr" target="_self">coap_add_attr</a>(r, <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("title"),
                <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("\"Internal Clock\""), 0);
  <a href="man_coap_add_attr.html#coap_add_attr" target="_self">coap_add_attr</a>(r, <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("rt"), <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("\"secs\""),
                0);
  <a href="man_coap_add_attr.html#coap_add_attr" target="_self">coap_add_attr</a>(r, <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("if"), <a href="man_coap_make_str_const.html#coap_make_str_const" target="_self">coap_make_str_const</a>("\"clock\""),
                0);

  <a href="man_coap_add_resource.html#coap_add_resource" target="_self">coap_add_resource</a>(context, r);
  time_resource = r;

  /* ... Loop waiting for incoming traffic ... */
  while (!not_exit) {
    <a href="man_coap_io_process.html#coap_io_process" target="_self">coap_io_process</a>(context, 1000);

    /* Cause a notification to anyone Observing 'time' */
    <a href="man_coap_resource_notify_observers.html#coap_resource_notify_observers" target="_self">coap_resource_notify_observers</a>(time_resource, NULL);
  }

  /* Clean up */

  <a href="man_coap_free_context.html#coap_free_context" target="_self">coap_free_context</a>(context);
  <a href="man_coap_cleanup.html#coap_cleanup" target="_self">coap_cleanup</a>();

}</pre></div><div class="refsect1"><a id="_see_also"></a><h2>SEE ALSO</h2><p><span class="strong"><strong><a class="st-desc" href="man_coap_init.html#coap_init" target="_self">coap_init</a></strong></span>(3) <span class="strong"><strong><a class="st-desc" href="man_coap_pdu_setup.html#coap_pdu_setup" target="_self">coap_pdu_setup</a></strong></span>(3), <span class="strong"><strong><a class="st-desc" href="man_coap_observe.html#coap_observe" target="_self">coap_observe</a></strong></span>(3), and <span class="strong"><strong><a class="st-desc" href="man_coap_resource.html#coap_resource" target="_self">coap_resource</a></strong></span>(3)</p></div><div class="refsect1"><a id="_further_information"></a><h2>FURTHER INFORMATION</h2><p>See</p><p>"<a class="ulink" href="https://rfc-editor.org/rfc/rfc7252" target="_top">RFC7252: The Constrained Application Protocol (CoAP)</a>"</p><p>"<a class="ulink" href="https://rfc-editor.org/rfc/rfc7959" target="_top">RFC7959: Block-Wise Transfers in the Constrained Application Protocol (CoAP)</a>"</p><p>for further information.</p></div><div class="refsect1"><a id="_bugs"></a><h2>BUGS</h2><p>Please report bugs on the mailing list for libcoap:
<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a> or raise an issue on GitHub at
<a class="ulink" href="https://github.com/obgm/libcoap/issues" target="_top">https://github.com/obgm/libcoap/issues</a></p></div><div class="refsect1"><a id="_authors"></a><h2>AUTHORS</h2><p>The libcoap project &lt;<a class="ulink" href="mailto:libcoap-developers@lists.sourceforge.net" target="_top">libcoap-developers@lists.sourceforge.net</a>&gt;</p></div></div></body></html> coap_add_data_large_response(3)</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 6 2023 17:16:41 for libcoap by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
